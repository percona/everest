---
name: Custom build
on:
  workflow_dispatch:
    inputs:
      vs_branch:
        required: true
        default: main
        description: "Version Service branch with the new build to checkout"
      image:
        required: true
        description: "Full name of the upstream image to test"
      upstream:
        type: choice
        description: "The upstream operator"
        required: true
        options:
          - percona-xtradb-cluster-operator
          - percona-server-mongodb-operator
          - percona-postgresql-operator
  push: # !!! remove before merge
    branches:
      - EVEREST-1563-operator-early-adoption

permissions:
  contents: read
  packages: write
  checks: write
  pull-requests: write

jobs:
  test:
    name: Test
    timeout-minutes: 10

    strategy:
      fail-fast: false
      matrix:
        go-version: [ 1.23.x ]
        may-fail: [ false ]

    continue-on-error: ${{ matrix.may-fail }}
    runs-on: ubuntu-20.04

    env:
      # VERSION constant higher than any potentially existing
      VERSION: 1.10000.0-rc20241121101830
      CLI_PREREQUISITES: ">= 1.2.0"
      K8S_PREREQUISITES: ">= 1.27"
      VS_PORT: 8081
      VS_URL: ""
      LOCAL_REGISTRY_PORT: 5000
      LOCAL_REGISTRY: ""
      ARCH: ""
      OS: ""
      TOOLS_PATH: "/opt/tools/bin"
      # !!! revert to using inputs
      # UPSTREAM_REPO: ${{ github.event.inputs.upstream }}
      UPSTREAM_REPO: "percona-xtradb-cluster-operator"
      # IMAGE: ${{ github.event.inputs.image }}
      IMAGE: "docker.io/percona/percona-xtradb-cluster-operator:1.15.1-community-bundle"
      VS_BRANCH: ${{ github.event.inputs.vs_branch }}

    steps:
      - name: Set environment variables
        run: |
          echo "ARCH=$(uname -m | sed 's/x86_64/amd64/;s/aarch64/arm64/')" >> $GITHUB_ENV
          echo "OS=$(uname | awk '{print tolower($0)}')" >> $GITHUB_ENV
          echo "LOCAL_REGISTRY=localhost:$LOCAL_REGISTRY_PORT" >> $GITHUB_ENV
          echo "VS_URL=http://localhost:$VS_PORT" >> $GITHUB_ENV

      - name: Set up Go release
        uses: percona-platform/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}

      - name: Set GO_VERSION environment variable
        run: |
          go version
          echo "GO_VERSION=$(go version)" >> $GITHUB_ENV

      - name: Enable Go modules cache
        uses: percona-platform/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ matrix.os }}-go-${{ matrix.go-version }}-modules-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ matrix.os }}-go-${{ matrix.go-version }}-modules-

      - name: Enable Go build cache
        uses: percona-platform/cache@v3
        with:
          path: ~/.cache/go-build
          key: ${{ matrix.os }}-go-${{ matrix.go-version }}-build-${{ github.ref }}-${{ hashFiles('**') }}
          restore-keys: |
            ${{ matrix.os }}-go-${{ matrix.go-version }}-build-${{ github.ref }}-
            ${{ matrix.os }}-go-${{ matrix.go-version }}-build-

      - name: Start local Kubernetes cluster with the local registry
        uses: medyagh/setup-minikube@latest
        id: minikube
        with:
          cpus: 2
          memory: 2000m
          addons: registry
          insecure-registry: "localhost:5000"

      - name: Expose local registry # !!! remove local registry, keeping it for now to push VS images
        run: |
          kubectl port-forward --namespace kube-system service/registry $LOCAL_REGISTRY_PORT:80 &

      - name: VS - checkout
        uses: actions/checkout@v4
        with:
          repository: Percona-Lab/percona-version-service
          ref: ${{ env.VS_BRANCH }}
          path: percona-version-service
          token: ${{ secrets.ROBOT_TOKEN }}

      - name: VS - update
        run: |
          cd percona-version-service
          make init
          # create an entry for the new Everest version
          printf "version: $VERSION\nsupported:\n  cli: '$CLI_PREREQUISITES'\n  kubernetes: '$K8S_PREREQUISITES'" > "sources/metadata/everest/$VERSION.yaml"


      - name: Build and Push VS dev image
        uses: docker/build-push-action@v6
        with:
          context: percona-version-service
          push: true
          tags: ${{ env.LOCAL_REGISTRY}}/perconalab/version-service:dev


      - name: Apply VS manifest
        run: |
          kubectl create ns everest-system
          sed -i "s/perconalab\/version-service:.*/$LOCAL_REGISTRY\/perconalab\/version-service:dev/g" percona-version-service/deploy.yaml
          kubectl apply -f percona-version-service/deploy.yaml -n everest-system
          kubectl wait --for=jsonpath='{.status.readyReplicas}'=3 deployment/percona-version-service -n everest-system
          kubectl port-forward svc/percona-version-service $VS_PORT:80 -n everest-system &

      - name: Login to GitHub Container Registry  # !!! move above, prior VS chagnes
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Operator - check out
        uses: actions/checkout@v4
        with:
          repository: percona/everest-operator
          path: everest-operator
          token: ${{ secrets.ROBOT_TOKEN }}

      - name: Operator - install operator-sdk
        run: |
          mkdir -p $TOOLS_PATH
          echo $TOOLS_PATH >> $GITHUB_PATH

          export OPERATOR_SDK_DL_URL=https://github.com/operator-framework/operator-sdk/releases/download/v1.25.2
          curl -LO ${OPERATOR_SDK_DL_URL}/operator-sdk_${OS}_${ARCH}

          gpg --keyserver keyserver.ubuntu.com --recv-keys 052996E2A20B5C7E

          curl -LO ${OPERATOR_SDK_DL_URL}/checksums.txt
          curl -LO ${OPERATOR_SDK_DL_URL}/checksums.txt.asc
          gpg -u "Operator SDK (release) <cncf-operator-sdk@cncf.io>" --verify checksums.txt.asc

          grep operator-sdk_${OS}_${ARCH} checksums.txt | sha256sum -c -

          chmod +x operator-sdk_${OS}_${ARCH}
          mv operator-sdk_${OS}_${ARCH} $TOOLS_PATH/operator-sdk

      - name: Operator - build and bundle
        run: |
          cd everest-operator
          make build manifests bundle

      - name: Operator - setup Docker meta for everest-operator
        id: operator_meta
        uses: docker/metadata-action@v5
        with:
          images: |
            perconalab/everest-operator
          tags: |
            type=raw,value=${{ env.VERSION }}

      - name: Operator - setup Docker meta for everest-operator-bundle
        id: bundle_meta
        uses: docker/metadata-action@v5
        with:
          images: |
            perconalab/everest-operator-bundle
          tags: |
            type=raw,value=${{ env.VERSION }}

      - name: Operator - push everest-operator image
        uses: docker/build-push-action@v6
        with:
          context: everest-operator
          push: true
          tags: ${{ steps.operator_meta.outputs.tags }}

      - name: Operator - push everest-operator-bundle image
        uses: docker/build-push-action@v6
        with:
          context: everest-operator
          push: true
          tags: ${{ steps.bundle_meta.outputs.tags }}
          file: everest-operator/bundle.Dockerfile

      - name: Catalog - checkout
        uses: actions/checkout@v4
        with:
          repository: percona/everest-catalog
          path: everest-catalog
          token: ${{ secrets.ROBOT_TOKEN }}

      - name: Catalog - update veneer file
        run: |
          cd everest-catalog/tools
          go run . \
            --veneer-file ../veneer/everest-operator.yaml \
            --channel fast-v0  \
            --new-version ${{ env.VERSION }} \
            --test-repo \

          cd ..
          curl -Lo /tmp/opm https://github.com/operator-framework/operator-registry/releases/download/v1.44.0/${OS}-${ARCH}-opm
          chmod +x /tmp/opm
          /tmp/opm alpha render-template basic --skip-tls -o yaml < veneer/everest-operator.yaml > catalog/everest-operator/catalog.yaml

          # Check if catalog has the new version listed
          if ! grep -q "$VERSION$" catalog/everest-operator/catalog.yaml; then
            echo "catalog/everest-operator/catalog.yaml does not include the version $VERSION"
            exit 1
          fi

          # Add a new record to the upstream veneer
          yq e ".Stable.Bundles += {\"Image\": \"$IMAGE\"}" veneer/${UPSTREAM_REPO}.yaml > temp.yaml && mv temp.yaml veneer/${UPSTREAM_REPO}.yaml

          # Generate upstream catalog
          /tmp/opm alpha render-template semver --skip-tls -o yaml < veneer/${UPSTREAM_REPO}.yaml > catalog/${UPSTREAM_REPO}/catalog.yaml

          # Check if upstream catalog has the new image listed
          if ! grep -q "$IMAGE$" catalog/${UPSTREAM_REPO}/catalog.yaml; then
            echo "catalog/${UPSTREAM_REPO}/catalog.yaml does not include the version $IMAGE"
            exit 1
          fi

          git diff

      - name: Catalog - setup Docker meta for everest-catalog
        id: catalog_meta
        uses: docker/metadata-action@v5
        with:
          images: |
            perconalab/everest-catalog
          tags: |
            type=raw,value=${{ env.VERSION }}
            type=raw,value=latest

      - name: Catalog - push everest-catalog image
        uses: docker/build-push-action@v6
        with:
          context: everest-catalog
          push: true
          tags: ${{ steps.catalog_meta.outputs.tags }}
          file: everest-catalog/everest-catalog.Dockerfile


      - name: Everest - check out
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ROBOT_TOKEN }}
          ref: EVEREST-1563-operator-early-adoption # !!! delete before merge

      - name: Everest - setup golang
        uses: actions/setup-go@v5
        with:
          go-version-file: "./go.mod"


      - name: Everest - update sources
        run: |
          # Update deploy manifest
          sed -i "s/perconalab\/everest.*/perconalab\/everest:$VERSION/g" deploy/quickstart-k8s.yaml
          sed -i "s/percona\/everest.*/perconalab\/everest:$VERSION/g" deploy/quickstart-k8s.yaml

          # Change version in Makefile
          sed -i "s/RELEASE_VERSION ?=.*/RELEASE_VERSION ?= v$VERSION/g" Makefile

          # Change release manifest link: use local path to the manifest file in version.go
          sed -i "s/https:\/\/raw.githubusercontent.com\/percona\/everest\/v%s\///g" pkg/version/version.go

          git status
      - name: Everest UI - setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9.4.0

      - name: Everest UI - run with Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: "pnpm"
          cache-dependency-path: ui/pnpm-lock.yaml

      - name: Everest UI - build
        run: |
          cd ui
          pnpm install
          EVEREST_OUT_DIR=${GITHUB_WORKSPACE}/public/dist/ pnpm build

      - name: Everest - build binary
        run: |
          if [[ $IS_RC == 1 ]]; then
            CGO_ENABLED=0 GOOS=linux GOARCH=amd64 make rc
          else
            CGO_ENABLED=0 GOOS=linux GOARCH=amd64 make release
          fi

      - name: Everest - push Everest image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags:  perconalab/everest:${{ env.VERSION }}

      - name: Provision Everest using CLI
        shell: bash
        run: |
          make init
          make build-cli
          ./bin/everestctl install -v \
            --version $VERSION \
            --version-metadata-url $VS_URL \
            --operator.mongodb \
            --operator.postgresql \
            --operator.xtradb-cluster \
            --skip-wizard \
            --namespaces everest
