// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	effector "github.com/casbin/casbin/v2/effector"
	model "github.com/casbin/casbin/v2/model"
	persist "github.com/casbin/casbin/v2/persist"
	rbac "github.com/casbin/casbin/v2/rbac"
	govaluate "github.com/casbin/govaluate"
	mock "github.com/stretchr/testify/mock"
)

// IEnforcer is an autogenerated mock type for the IEnforcer type
type IEnforcer struct {
	mock.Mock
}

// AddFunction provides a mock function with given fields: name, function
func (_m *IEnforcer) AddFunction(name string, function govaluate.ExpressionFunction) {
	_m.Called(name, function)
}

// AddGroupingPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) AddGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddGroupingPoliciesEx provides a mock function with given fields: rules
func (_m *IEnforcer) AddGroupingPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) AddGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedGroupingPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) AddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) AddNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) AddPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPermissionsForUser provides a mock function with given fields: user, permissions
func (_m *IEnforcer) AddPermissionsForUser(user string, permissions ...[]string) (bool, error) {
	_va := make([]interface{}, len(permissions))
	for _i := range permissions {
		_va[_i] = permissions[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...[]string) (bool, error)); ok {
		return rf(user, permissions...)
	}
	if rf, ok := ret.Get(0).(func(string, ...[]string) bool); ok {
		r0 = rf(user, permissions...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...[]string) error); ok {
		r1 = rf(user, permissions...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) AddPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPoliciesEx provides a mock function with given fields: rules
func (_m *IEnforcer) AddPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPolicy provides a mock function with given fields: params
func (_m *IEnforcer) AddPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddRoleForUser provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) AddRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) AddRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchEnforce provides a mock function with given fields: requests
func (_m *IEnforcer) BatchEnforce(requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforce")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]interface{}) ([]bool, error)); ok {
		return rf(requests)
	}
	if rf, ok := ret.Get(0).(func([][]interface{}) []bool); ok {
		r0 = rf(requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func([][]interface{}) error); ok {
		r1 = rf(requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchEnforceWithMatcher provides a mock function with given fields: matcher, requests
func (_m *IEnforcer) BatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(matcher, requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforceWithMatcher")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) ([]bool, error)); ok {
		return rf(matcher, requests)
	}
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) []bool); ok {
		r0 = rf(matcher, requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(string, [][]interface{}) error); ok {
		r1 = rf(matcher, requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildRoleLinks provides a mock function with no fields
func (_m *IEnforcer) BuildRoleLinks() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BuildRoleLinks")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearPolicy provides a mock function with no fields
func (_m *IEnforcer) ClearPolicy() {
	_m.Called()
}

// DeleteAllUsersByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) DeleteAllUsersByDomain(domain string) (bool, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllUsersByDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDomains provides a mock function with given fields: domains
func (_m *IEnforcer) DeleteDomains(domains ...string) (bool, error) {
	_va := make([]interface{}, len(domains))
	for _i := range domains {
		_va[_i] = domains[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomains")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(domains...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(domains...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(domains...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermission provides a mock function with given fields: permission
func (_m *IEnforcer) DeletePermission(permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) DeletePermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermissionsForUser provides a mock function with given fields: user
func (_m *IEnforcer) DeletePermissionsForUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRole provides a mock function with given fields: role
func (_m *IEnforcer) DeleteRole(role string) (bool, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRoleForUser provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) DeleteRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) DeleteRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRolesForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) DeleteRolesForUser(user string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRolesForUserInDomain provides a mock function with given fields: user, domain
func (_m *IEnforcer) DeleteRolesForUserInDomain(user string, domain string) (bool, error) {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(user, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(user, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: user
func (_m *IEnforcer) DeleteUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableAutoBuildRoleLinks provides a mock function with given fields: autoBuildRoleLinks
func (_m *IEnforcer) EnableAutoBuildRoleLinks(autoBuildRoleLinks bool) {
	_m.Called(autoBuildRoleLinks)
}

// EnableAutoNotifyWatcher provides a mock function with given fields: enable
func (_m *IEnforcer) EnableAutoNotifyWatcher(enable bool) {
	_m.Called(enable)
}

// EnableAutoSave provides a mock function with given fields: autoSave
func (_m *IEnforcer) EnableAutoSave(autoSave bool) {
	_m.Called(autoSave)
}

// EnableEnforce provides a mock function with given fields: enable
func (_m *IEnforcer) EnableEnforce(enable bool) {
	_m.Called(enable)
}

// EnableLog provides a mock function with given fields: enable
func (_m *IEnforcer) EnableLog(enable bool) {
	_m.Called(enable)
}

// Enforce provides a mock function with given fields: rvals
func (_m *IEnforcer) Enforce(rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Enforce")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnforceEx provides a mock function with given fields: rvals
func (_m *IEnforcer) EnforceEx(rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceEx")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, []string, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) []string); ok {
		r1 = rf(rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(...interface{}) error); ok {
		r2 = rf(rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EnforceExWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *IEnforcer) EnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceExWithMatcher")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, []string, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) []string); ok {
		r1 = rf(matcher, rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(string, ...interface{}) error); ok {
		r2 = rf(matcher, rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EnforceWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *IEnforcer) EnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceWithMatcher")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(matcher, rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdapter provides a mock function with no fields
func (_m *IEnforcer) GetAdapter() persist.Adapter {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAdapter")
	}

	var r0 persist.Adapter
	if rf, ok := ret.Get(0).(func() persist.Adapter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persist.Adapter)
		}
	}

	return r0
}

// GetAllActions provides a mock function with no fields
func (_m *IEnforcer) GetAllActions() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllDomains provides a mock function with no fields
func (_m *IEnforcer) GetAllDomains() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllDomains")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllNamedActions provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedActions(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllNamedObjects provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedObjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllNamedRoles provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedRoles(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllNamedSubjects provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedSubjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllObjects provides a mock function with no fields
func (_m *IEnforcer) GetAllObjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllRoles provides a mock function with no fields
func (_m *IEnforcer) GetAllRoles() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllRolesByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) GetAllRolesByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllRolesByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllSubjects provides a mock function with no fields
func (_m *IEnforcer) GetAllSubjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllUsersByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) GetAllUsersByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUsersByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupingPolicy provides a mock function with no fields
func (_m *IEnforcer) GetGroupingPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImplicitPermissionsForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImplicitRolesForUser provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetImplicitRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImplicitUsersForPermission provides a mock function with given fields: permission
func (_m *IEnforcer) GetImplicitUsersForPermission(permission ...string) ([]string, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitUsersForPermission")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) ([]string, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) []string); ok {
		r0 = rf(permission...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetModel provides a mock function with no fields
func (_m *IEnforcer) GetModel() model.Model {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetModel")
	}

	var r0 model.Model
	if rf, ok := ret.Get(0).(func() model.Model); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.Model)
		}
	}

	return r0
}

// GetNamedGroupingPolicy provides a mock function with given fields: ptype
func (_m *IEnforcer) GetNamedGroupingPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamedPolicy provides a mock function with given fields: ptype
func (_m *IEnforcer) GetNamedPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionsForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionsForUserInDomain provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetPermissionsForUserInDomain(user string, domain string) [][]string {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUserInDomain")
	}

	var r0 [][]string
	if rf, ok := ret.Get(0).(func(string, string) [][]string); ok {
		r0 = rf(user, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	return r0
}

// GetPolicy provides a mock function with no fields
func (_m *IEnforcer) GetPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoleManager provides a mock function with no fields
func (_m *IEnforcer) GetRoleManager() rbac.RoleManager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRoleManager")
	}

	var r0 rbac.RoleManager
	if rf, ok := ret.Get(0).(func() rbac.RoleManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rbac.RoleManager)
		}
	}

	return r0
}

// GetRolesForUser provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRolesForUserInDomain provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetRolesForUserInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUserInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetUsersForRole provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetUsersForRole(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRole")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersForRoleInDomain provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetUsersForRoleInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRoleInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// HasGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) HasGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) HasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) HasNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasPermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) HasPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasPolicy provides a mock function with given fields: params
func (_m *IEnforcer) HasPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasRoleForUser provides a mock function with given fields: name, role, domain
func (_m *IEnforcer) HasRoleForUser(name string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(name, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(name, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(name, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitWithAdapter provides a mock function with given fields: modelPath, adapter
func (_m *IEnforcer) InitWithAdapter(modelPath string, adapter persist.Adapter) error {
	ret := _m.Called(modelPath, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, persist.Adapter) error); ok {
		r0 = rf(modelPath, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InitWithFile provides a mock function with given fields: modelPath, policyPath
func (_m *IEnforcer) InitWithFile(modelPath string, policyPath string) error {
	ret := _m.Called(modelPath, policyPath)

	if len(ret) == 0 {
		panic("no return value specified for InitWithFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(modelPath, policyPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InitWithModelAndAdapter provides a mock function with given fields: m, adapter
func (_m *IEnforcer) InitWithModelAndAdapter(m model.Model, adapter persist.Adapter) error {
	ret := _m.Called(m, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithModelAndAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Model, persist.Adapter) error); ok {
		r0 = rf(m, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsFiltered provides a mock function with no fields
func (_m *IEnforcer) IsFiltered() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsFiltered")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LoadFilteredPolicy provides a mock function with given fields: filter
func (_m *IEnforcer) LoadFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadIncrementalFilteredPolicy provides a mock function with given fields: filter
func (_m *IEnforcer) LoadIncrementalFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadIncrementalFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadModel provides a mock function with no fields
func (_m *IEnforcer) LoadModel() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadModel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadPolicy provides a mock function with no fields
func (_m *IEnforcer) LoadPolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveGroupingPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) RemoveGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) RemoveGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) RemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) RemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) RemoveNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) RemoveNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemovePolicies provides a mock function with given fields: rules
func (_m *IEnforcer) RemovePolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemovePolicy provides a mock function with given fields: params
func (_m *IEnforcer) RemovePolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SavePolicy provides a mock function with no fields
func (_m *IEnforcer) SavePolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SavePolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SelfAddPolicies provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfAddPoliciesEx provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfAddPolicy provides a mock function with given fields: sec, ptype, rule
func (_m *IEnforcer) SelfAddPolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfRemoveFilteredPolicy provides a mock function with given fields: sec, ptype, fieldIndex, fieldValues
func (_m *IEnforcer) SelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, sec, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) (bool, error)); ok {
		return rf(sec, ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) bool); ok {
		r0 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, int, ...string) error); ok {
		r1 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfRemovePolicies provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfRemovePolicy provides a mock function with given fields: sec, ptype, rule
func (_m *IEnforcer) SelfRemovePolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfUpdatePolicies provides a mock function with given fields: sec, ptype, oldRules, newRules
func (_m *IEnforcer) SelfUpdatePolicies(sec string, ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) bool); ok {
		r0 = rf(sec, ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string, [][]string) error); ok {
		r1 = rf(sec, ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelfUpdatePolicy provides a mock function with given fields: sec, ptype, oldRule, newRule
func (_m *IEnforcer) SelfUpdatePolicy(sec string, ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) (bool, error)); ok {
		return rf(sec, ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) bool); ok {
		r0 = rf(sec, ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string, []string) error); ok {
		r1 = rf(sec, ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAdapter provides a mock function with given fields: adapter
func (_m *IEnforcer) SetAdapter(adapter persist.Adapter) {
	_m.Called(adapter)
}

// SetEffector provides a mock function with given fields: eft
func (_m *IEnforcer) SetEffector(eft effector.Effector) {
	_m.Called(eft)
}

// SetModel provides a mock function with given fields: m
func (_m *IEnforcer) SetModel(m model.Model) {
	_m.Called(m)
}

// SetRoleManager provides a mock function with given fields: rm
func (_m *IEnforcer) SetRoleManager(rm rbac.RoleManager) {
	_m.Called(rm)
}

// SetWatcher provides a mock function with given fields: watcher
func (_m *IEnforcer) SetWatcher(watcher persist.Watcher) error {
	ret := _m.Called(watcher)

	if len(ret) == 0 {
		panic("no return value specified for SetWatcher")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(persist.Watcher) error); ok {
		r0 = rf(watcher)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateFilteredPolicies provides a mock function with given fields: newPolicies, fieldIndex, fieldValues
func (_m *IEnforcer) UpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, newPolicies, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFilteredPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) (bool, error)); ok {
		return rf(newPolicies, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) bool); ok {
		r0 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, int, ...string) error); ok {
		r1 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGroupingPolicies provides a mock function with given fields: oldRules, newRules
func (_m *IEnforcer) UpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGroupingPolicy provides a mock function with given fields: oldRule, newRule
func (_m *IEnforcer) UpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNamedGroupingPolicies provides a mock function with given fields: ptype, oldRules, newRules
func (_m *IEnforcer) UpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) (bool, error)); ok {
		return rf(ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) bool); ok {
		r0 = rf(ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string, [][]string) error); ok {
		r1 = rf(ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNamedGroupingPolicy provides a mock function with given fields: ptype, oldRule, newRule
func (_m *IEnforcer) UpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []string, []string) (bool, error)); ok {
		return rf(ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, []string, []string) bool); ok {
		r0 = rf(ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, []string, []string) error); ok {
		r1 = rf(ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePolicies provides a mock function with given fields: oldPolicies, newPolicies
func (_m *IEnforcer) UpdatePolicies(oldPolicies [][]string, newPolicies [][]string) (bool, error) {
	ret := _m.Called(oldPolicies, newPolicies)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldPolicies, newPolicies)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldPolicies, newPolicies)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldPolicies, newPolicies)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePolicy provides a mock function with given fields: oldPolicy, newPolicy
func (_m *IEnforcer) UpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error) {
	ret := _m.Called(oldPolicy, newPolicy)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldPolicy, newPolicy)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldPolicy, newPolicy)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldPolicy, newPolicy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIEnforcer creates a new instance of IEnforcer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIEnforcer(t interface {
	mock.TestingT
	Cleanup(func())
}) *IEnforcer {
	mock := &IEnforcer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
