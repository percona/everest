// Code generated by mockery v2.46.2. DO NOT EDIT.

package mocks

import (
	effector "github.com/casbin/casbin/v2/effector"
	model "github.com/casbin/casbin/v2/model"
	persist "github.com/casbin/casbin/v2/persist"
	rbac "github.com/casbin/casbin/v2/rbac"
	govaluate "github.com/casbin/govaluate"
	mock "github.com/stretchr/testify/mock"
)

// IEnforcer is an autogenerated mock type for the IEnforcer type
type IEnforcer struct {
	mock.Mock
}

type IEnforcer_Expecter struct {
	mock *mock.Mock
}

func (_m *IEnforcer) EXPECT() *IEnforcer_Expecter {
	return &IEnforcer_Expecter{mock: &_m.Mock}
}

// AddFunction provides a mock function with given fields: name, function
func (_m *IEnforcer) AddFunction(name string, function govaluate.ExpressionFunction) {
	_m.Called(name, function)
}

// IEnforcer_AddFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFunction'
type IEnforcer_AddFunction_Call struct {
	*mock.Call
}

// AddFunction is a helper method to define mock.On call
//   - name string
//   - function govaluate.ExpressionFunction
func (_e *IEnforcer_Expecter) AddFunction(name interface{}, function interface{}) *IEnforcer_AddFunction_Call {
	return &IEnforcer_AddFunction_Call{Call: _e.mock.On("AddFunction", name, function)}
}

func (_c *IEnforcer_AddFunction_Call) Run(run func(name string, function govaluate.ExpressionFunction)) *IEnforcer_AddFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(govaluate.ExpressionFunction))
	})
	return _c
}

func (_c *IEnforcer_AddFunction_Call) Return() *IEnforcer_AddFunction_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_AddFunction_Call) RunAndReturn(run func(string, govaluate.ExpressionFunction)) *IEnforcer_AddFunction_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupingPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) AddGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPolicies'
type IEnforcer_AddGroupingPolicies_Call struct {
	*mock.Call
}

// AddGroupingPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddGroupingPolicies(rules interface{}) *IEnforcer_AddGroupingPolicies_Call {
	return &IEnforcer_AddGroupingPolicies_Call{Call: _e.mock.On("AddGroupingPolicies", rules)}
}

func (_c *IEnforcer_AddGroupingPolicies_Call) Run(run func(rules [][]string)) *IEnforcer_AddGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddGroupingPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_AddGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupingPoliciesEx provides a mock function with given fields: rules
func (_m *IEnforcer) AddGroupingPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddGroupingPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPoliciesEx'
type IEnforcer_AddGroupingPoliciesEx_Call struct {
	*mock.Call
}

// AddGroupingPoliciesEx is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddGroupingPoliciesEx(rules interface{}) *IEnforcer_AddGroupingPoliciesEx_Call {
	return &IEnforcer_AddGroupingPoliciesEx_Call{Call: _e.mock.On("AddGroupingPoliciesEx", rules)}
}

func (_c *IEnforcer_AddGroupingPoliciesEx_Call) Run(run func(rules [][]string)) *IEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddGroupingPoliciesEx_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddGroupingPoliciesEx_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) AddGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPolicy'
type IEnforcer_AddGroupingPolicy_Call struct {
	*mock.Call
}

// AddGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) AddGroupingPolicy(params ...interface{}) *IEnforcer_AddGroupingPolicy_Call {
	return &IEnforcer_AddGroupingPolicy_Call{Call: _e.mock.On("AddGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_AddGroupingPolicy_Call) Run(run func(params ...interface{})) *IEnforcer_AddGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_AddGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPolicies'
type IEnforcer_AddNamedGroupingPolicies_Call struct {
	*mock.Call
}

// AddNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddNamedGroupingPolicies(ptype interface{}, rules interface{}) *IEnforcer_AddNamedGroupingPolicies_Call {
	return &IEnforcer_AddNamedGroupingPolicies_Call{Call: _e.mock.On("AddNamedGroupingPolicies", ptype, rules)}
}

func (_c *IEnforcer_AddNamedGroupingPolicies_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedGroupingPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPoliciesEx'
type IEnforcer_AddNamedGroupingPoliciesEx_Call struct {
	*mock.Call
}

// AddNamedGroupingPoliciesEx is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddNamedGroupingPoliciesEx(ptype interface{}, rules interface{}) *IEnforcer_AddNamedGroupingPoliciesEx_Call {
	return &IEnforcer_AddNamedGroupingPoliciesEx_Call{Call: _e.mock.On("AddNamedGroupingPoliciesEx", ptype, rules)}
}

func (_c *IEnforcer_AddNamedGroupingPoliciesEx_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPoliciesEx_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPoliciesEx_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) AddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPolicy'
type IEnforcer_AddNamedGroupingPolicy_Call struct {
	*mock.Call
}

// AddNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) AddNamedGroupingPolicy(ptype interface{}, params ...interface{}) *IEnforcer_AddNamedGroupingPolicy_Call {
	return &IEnforcer_AddNamedGroupingPolicy_Call{Call: _e.mock.On("AddNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_AddNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPolicies'
type IEnforcer_AddNamedPolicies_Call struct {
	*mock.Call
}

// AddNamedPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddNamedPolicies(ptype interface{}, rules interface{}) *IEnforcer_AddNamedPolicies_Call {
	return &IEnforcer_AddNamedPolicies_Call{Call: _e.mock.On("AddNamedPolicies", ptype, rules)}
}

func (_c *IEnforcer_AddNamedPolicies_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_AddNamedPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddNamedPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_AddNamedPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPoliciesEx'
type IEnforcer_AddNamedPoliciesEx_Call struct {
	*mock.Call
}

// AddNamedPoliciesEx is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddNamedPoliciesEx(ptype interface{}, rules interface{}) *IEnforcer_AddNamedPoliciesEx_Call {
	return &IEnforcer_AddNamedPoliciesEx_Call{Call: _e.mock.On("AddNamedPoliciesEx", ptype, rules)}
}

func (_c *IEnforcer_AddNamedPoliciesEx_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddNamedPoliciesEx_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedPoliciesEx_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) AddNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPolicy'
type IEnforcer_AddNamedPolicy_Call struct {
	*mock.Call
}

// AddNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) AddNamedPolicy(ptype interface{}, params ...interface{}) *IEnforcer_AddNamedPolicy_Call {
	return &IEnforcer_AddNamedPolicy_Call{Call: _e.mock.On("AddNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_AddNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_AddNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddNamedPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_AddNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddPermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) AddPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddPermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPermissionForUser'
type IEnforcer_AddPermissionForUser_Call struct {
	*mock.Call
}

// AddPermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *IEnforcer_Expecter) AddPermissionForUser(user interface{}, permission ...interface{}) *IEnforcer_AddPermissionForUser_Call {
	return &IEnforcer_AddPermissionForUser_Call{Call: _e.mock.On("AddPermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *IEnforcer_AddPermissionForUser_Call) Run(run func(user string, permission ...string)) *IEnforcer_AddPermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddPermissionForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddPermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddPermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *IEnforcer_AddPermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddPermissionsForUser provides a mock function with given fields: user, permissions
func (_m *IEnforcer) AddPermissionsForUser(user string, permissions ...[]string) (bool, error) {
	_va := make([]interface{}, len(permissions))
	for _i := range permissions {
		_va[_i] = permissions[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...[]string) (bool, error)); ok {
		return rf(user, permissions...)
	}
	if rf, ok := ret.Get(0).(func(string, ...[]string) bool); ok {
		r0 = rf(user, permissions...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...[]string) error); ok {
		r1 = rf(user, permissions...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPermissionsForUser'
type IEnforcer_AddPermissionsForUser_Call struct {
	*mock.Call
}

// AddPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - permissions ...[]string
func (_e *IEnforcer_Expecter) AddPermissionsForUser(user interface{}, permissions ...interface{}) *IEnforcer_AddPermissionsForUser_Call {
	return &IEnforcer_AddPermissionsForUser_Call{Call: _e.mock.On("AddPermissionsForUser",
		append([]interface{}{user}, permissions...)...)}
}

func (_c *IEnforcer_AddPermissionsForUser_Call) Run(run func(user string, permissions ...[]string)) *IEnforcer_AddPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([][]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.([]string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddPermissionsForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddPermissionsForUser_Call) RunAndReturn(run func(string, ...[]string) (bool, error)) *IEnforcer_AddPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) AddPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPolicies'
type IEnforcer_AddPolicies_Call struct {
	*mock.Call
}

// AddPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddPolicies(rules interface{}) *IEnforcer_AddPolicies_Call {
	return &IEnforcer_AddPolicies_Call{Call: _e.mock.On("AddPolicies", rules)}
}

func (_c *IEnforcer_AddPolicies_Call) Run(run func(rules [][]string)) *IEnforcer_AddPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_AddPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddPoliciesEx provides a mock function with given fields: rules
func (_m *IEnforcer) AddPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPoliciesEx'
type IEnforcer_AddPoliciesEx_Call struct {
	*mock.Call
}

// AddPoliciesEx is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) AddPoliciesEx(rules interface{}) *IEnforcer_AddPoliciesEx_Call {
	return &IEnforcer_AddPoliciesEx_Call{Call: _e.mock.On("AddPoliciesEx", rules)}
}

func (_c *IEnforcer_AddPoliciesEx_Call) Run(run func(rules [][]string)) *IEnforcer_AddPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_AddPoliciesEx_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddPoliciesEx_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_AddPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddPolicy provides a mock function with given fields: params
func (_m *IEnforcer) AddPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPolicy'
type IEnforcer_AddPolicy_Call struct {
	*mock.Call
}

// AddPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) AddPolicy(params ...interface{}) *IEnforcer_AddPolicy_Call {
	return &IEnforcer_AddPolicy_Call{Call: _e.mock.On("AddPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_AddPolicy_Call) Run(run func(params ...interface{})) *IEnforcer_AddPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_AddPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddRoleForUser provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) AddRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRoleForUser'
type IEnforcer_AddRoleForUser_Call struct {
	*mock.Call
}

// AddRoleForUser is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain ...string
func (_e *IEnforcer_Expecter) AddRoleForUser(user interface{}, role interface{}, domain ...interface{}) *IEnforcer_AddRoleForUser_Call {
	return &IEnforcer_AddRoleForUser_Call{Call: _e.mock.On("AddRoleForUser",
		append([]interface{}{user, role}, domain...)...)}
}

func (_c *IEnforcer_AddRoleForUser_Call) Run(run func(user string, role string, domain ...string)) *IEnforcer_AddRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_AddRoleForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *IEnforcer_AddRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) AddRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_AddRoleForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRoleForUserInDomain'
type IEnforcer_AddRoleForUserInDomain_Call struct {
	*mock.Call
}

// AddRoleForUserInDomain is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain string
func (_e *IEnforcer_Expecter) AddRoleForUserInDomain(user interface{}, role interface{}, domain interface{}) *IEnforcer_AddRoleForUserInDomain_Call {
	return &IEnforcer_AddRoleForUserInDomain_Call{Call: _e.mock.On("AddRoleForUserInDomain", user, role, domain)}
}

func (_c *IEnforcer_AddRoleForUserInDomain_Call) Run(run func(user string, role string, domain string)) *IEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *IEnforcer_AddRoleForUserInDomain_Call) Return(_a0 bool, _a1 error) *IEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_AddRoleForUserInDomain_Call) RunAndReturn(run func(string, string, string) (bool, error)) *IEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// BatchEnforce provides a mock function with given fields: requests
func (_m *IEnforcer) BatchEnforce(requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforce")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]interface{}) ([]bool, error)); ok {
		return rf(requests)
	}
	if rf, ok := ret.Get(0).(func([][]interface{}) []bool); ok {
		r0 = rf(requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func([][]interface{}) error); ok {
		r1 = rf(requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_BatchEnforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchEnforce'
type IEnforcer_BatchEnforce_Call struct {
	*mock.Call
}

// BatchEnforce is a helper method to define mock.On call
//   - requests [][]interface{}
func (_e *IEnforcer_Expecter) BatchEnforce(requests interface{}) *IEnforcer_BatchEnforce_Call {
	return &IEnforcer_BatchEnforce_Call{Call: _e.mock.On("BatchEnforce", requests)}
}

func (_c *IEnforcer_BatchEnforce_Call) Run(run func(requests [][]interface{})) *IEnforcer_BatchEnforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]interface{}))
	})
	return _c
}

func (_c *IEnforcer_BatchEnforce_Call) Return(_a0 []bool, _a1 error) *IEnforcer_BatchEnforce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_BatchEnforce_Call) RunAndReturn(run func([][]interface{}) ([]bool, error)) *IEnforcer_BatchEnforce_Call {
	_c.Call.Return(run)
	return _c
}

// BatchEnforceWithMatcher provides a mock function with given fields: matcher, requests
func (_m *IEnforcer) BatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(matcher, requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforceWithMatcher")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) ([]bool, error)); ok {
		return rf(matcher, requests)
	}
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) []bool); ok {
		r0 = rf(matcher, requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(string, [][]interface{}) error); ok {
		r1 = rf(matcher, requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_BatchEnforceWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchEnforceWithMatcher'
type IEnforcer_BatchEnforceWithMatcher_Call struct {
	*mock.Call
}

// BatchEnforceWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - requests [][]interface{}
func (_e *IEnforcer_Expecter) BatchEnforceWithMatcher(matcher interface{}, requests interface{}) *IEnforcer_BatchEnforceWithMatcher_Call {
	return &IEnforcer_BatchEnforceWithMatcher_Call{Call: _e.mock.On("BatchEnforceWithMatcher", matcher, requests)}
}

func (_c *IEnforcer_BatchEnforceWithMatcher_Call) Run(run func(matcher string, requests [][]interface{})) *IEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]interface{}))
	})
	return _c
}

func (_c *IEnforcer_BatchEnforceWithMatcher_Call) Return(_a0 []bool, _a1 error) *IEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_BatchEnforceWithMatcher_Call) RunAndReturn(run func(string, [][]interface{}) ([]bool, error)) *IEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// BuildRoleLinks provides a mock function with given fields:
func (_m *IEnforcer) BuildRoleLinks() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BuildRoleLinks")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_BuildRoleLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildRoleLinks'
type IEnforcer_BuildRoleLinks_Call struct {
	*mock.Call
}

// BuildRoleLinks is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) BuildRoleLinks() *IEnforcer_BuildRoleLinks_Call {
	return &IEnforcer_BuildRoleLinks_Call{Call: _e.mock.On("BuildRoleLinks")}
}

func (_c *IEnforcer_BuildRoleLinks_Call) Run(run func()) *IEnforcer_BuildRoleLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_BuildRoleLinks_Call) Return(_a0 error) *IEnforcer_BuildRoleLinks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_BuildRoleLinks_Call) RunAndReturn(run func() error) *IEnforcer_BuildRoleLinks_Call {
	_c.Call.Return(run)
	return _c
}

// ClearPolicy provides a mock function with given fields:
func (_m *IEnforcer) ClearPolicy() {
	_m.Called()
}

// IEnforcer_ClearPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearPolicy'
type IEnforcer_ClearPolicy_Call struct {
	*mock.Call
}

// ClearPolicy is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) ClearPolicy() *IEnforcer_ClearPolicy_Call {
	return &IEnforcer_ClearPolicy_Call{Call: _e.mock.On("ClearPolicy")}
}

func (_c *IEnforcer_ClearPolicy_Call) Run(run func()) *IEnforcer_ClearPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_ClearPolicy_Call) Return() *IEnforcer_ClearPolicy_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_ClearPolicy_Call) RunAndReturn(run func()) *IEnforcer_ClearPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllUsersByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) DeleteAllUsersByDomain(domain string) (bool, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllUsersByDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteAllUsersByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllUsersByDomain'
type IEnforcer_DeleteAllUsersByDomain_Call struct {
	*mock.Call
}

// DeleteAllUsersByDomain is a helper method to define mock.On call
//   - domain string
func (_e *IEnforcer_Expecter) DeleteAllUsersByDomain(domain interface{}) *IEnforcer_DeleteAllUsersByDomain_Call {
	return &IEnforcer_DeleteAllUsersByDomain_Call{Call: _e.mock.On("DeleteAllUsersByDomain", domain)}
}

func (_c *IEnforcer_DeleteAllUsersByDomain_Call) Run(run func(domain string)) *IEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_DeleteAllUsersByDomain_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteAllUsersByDomain_Call) RunAndReturn(run func(string) (bool, error)) *IEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDomains provides a mock function with given fields: domains
func (_m *IEnforcer) DeleteDomains(domains ...string) (bool, error) {
	_va := make([]interface{}, len(domains))
	for _i := range domains {
		_va[_i] = domains[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomains")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(domains...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(domains...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(domains...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteDomains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDomains'
type IEnforcer_DeleteDomains_Call struct {
	*mock.Call
}

// DeleteDomains is a helper method to define mock.On call
//   - domains ...string
func (_e *IEnforcer_Expecter) DeleteDomains(domains ...interface{}) *IEnforcer_DeleteDomains_Call {
	return &IEnforcer_DeleteDomains_Call{Call: _e.mock.On("DeleteDomains",
		append([]interface{}{}, domains...)...)}
}

func (_c *IEnforcer_DeleteDomains_Call) Run(run func(domains ...string)) *IEnforcer_DeleteDomains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_DeleteDomains_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteDomains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteDomains_Call) RunAndReturn(run func(...string) (bool, error)) *IEnforcer_DeleteDomains_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermission provides a mock function with given fields: permission
func (_m *IEnforcer) DeletePermission(permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeletePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermission'
type IEnforcer_DeletePermission_Call struct {
	*mock.Call
}

// DeletePermission is a helper method to define mock.On call
//   - permission ...string
func (_e *IEnforcer_Expecter) DeletePermission(permission ...interface{}) *IEnforcer_DeletePermission_Call {
	return &IEnforcer_DeletePermission_Call{Call: _e.mock.On("DeletePermission",
		append([]interface{}{}, permission...)...)}
}

func (_c *IEnforcer_DeletePermission_Call) Run(run func(permission ...string)) *IEnforcer_DeletePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_DeletePermission_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeletePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeletePermission_Call) RunAndReturn(run func(...string) (bool, error)) *IEnforcer_DeletePermission_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) DeletePermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeletePermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermissionForUser'
type IEnforcer_DeletePermissionForUser_Call struct {
	*mock.Call
}

// DeletePermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *IEnforcer_Expecter) DeletePermissionForUser(user interface{}, permission ...interface{}) *IEnforcer_DeletePermissionForUser_Call {
	return &IEnforcer_DeletePermissionForUser_Call{Call: _e.mock.On("DeletePermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *IEnforcer_DeletePermissionForUser_Call) Run(run func(user string, permission ...string)) *IEnforcer_DeletePermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_DeletePermissionForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeletePermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeletePermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *IEnforcer_DeletePermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermissionsForUser provides a mock function with given fields: user
func (_m *IEnforcer) DeletePermissionsForUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeletePermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermissionsForUser'
type IEnforcer_DeletePermissionsForUser_Call struct {
	*mock.Call
}

// DeletePermissionsForUser is a helper method to define mock.On call
//   - user string
func (_e *IEnforcer_Expecter) DeletePermissionsForUser(user interface{}) *IEnforcer_DeletePermissionsForUser_Call {
	return &IEnforcer_DeletePermissionsForUser_Call{Call: _e.mock.On("DeletePermissionsForUser", user)}
}

func (_c *IEnforcer_DeletePermissionsForUser_Call) Run(run func(user string)) *IEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_DeletePermissionsForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeletePermissionsForUser_Call) RunAndReturn(run func(string) (bool, error)) *IEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRole provides a mock function with given fields: role
func (_m *IEnforcer) DeleteRole(role string) (bool, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRole'
type IEnforcer_DeleteRole_Call struct {
	*mock.Call
}

// DeleteRole is a helper method to define mock.On call
//   - role string
func (_e *IEnforcer_Expecter) DeleteRole(role interface{}) *IEnforcer_DeleteRole_Call {
	return &IEnforcer_DeleteRole_Call{Call: _e.mock.On("DeleteRole", role)}
}

func (_c *IEnforcer_DeleteRole_Call) Run(run func(role string)) *IEnforcer_DeleteRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_DeleteRole_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteRole_Call) RunAndReturn(run func(string) (bool, error)) *IEnforcer_DeleteRole_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRoleForUser provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) DeleteRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoleForUser'
type IEnforcer_DeleteRoleForUser_Call struct {
	*mock.Call
}

// DeleteRoleForUser is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain ...string
func (_e *IEnforcer_Expecter) DeleteRoleForUser(user interface{}, role interface{}, domain ...interface{}) *IEnforcer_DeleteRoleForUser_Call {
	return &IEnforcer_DeleteRoleForUser_Call{Call: _e.mock.On("DeleteRoleForUser",
		append([]interface{}{user, role}, domain...)...)}
}

func (_c *IEnforcer_DeleteRoleForUser_Call) Run(run func(user string, role string, domain ...string)) *IEnforcer_DeleteRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_DeleteRoleForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *IEnforcer_DeleteRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *IEnforcer) DeleteRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteRoleForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoleForUserInDomain'
type IEnforcer_DeleteRoleForUserInDomain_Call struct {
	*mock.Call
}

// DeleteRoleForUserInDomain is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain string
func (_e *IEnforcer_Expecter) DeleteRoleForUserInDomain(user interface{}, role interface{}, domain interface{}) *IEnforcer_DeleteRoleForUserInDomain_Call {
	return &IEnforcer_DeleteRoleForUserInDomain_Call{Call: _e.mock.On("DeleteRoleForUserInDomain", user, role, domain)}
}

func (_c *IEnforcer_DeleteRoleForUserInDomain_Call) Run(run func(user string, role string, domain string)) *IEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *IEnforcer_DeleteRoleForUserInDomain_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteRoleForUserInDomain_Call) RunAndReturn(run func(string, string, string) (bool, error)) *IEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRolesForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) DeleteRolesForUser(user string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRolesForUser'
type IEnforcer_DeleteRolesForUser_Call struct {
	*mock.Call
}

// DeleteRolesForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *IEnforcer_Expecter) DeleteRolesForUser(user interface{}, domain ...interface{}) *IEnforcer_DeleteRolesForUser_Call {
	return &IEnforcer_DeleteRolesForUser_Call{Call: _e.mock.On("DeleteRolesForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *IEnforcer_DeleteRolesForUser_Call) Run(run func(user string, domain ...string)) *IEnforcer_DeleteRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_DeleteRolesForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteRolesForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *IEnforcer_DeleteRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRolesForUserInDomain provides a mock function with given fields: user, domain
func (_m *IEnforcer) DeleteRolesForUserInDomain(user string, domain string) (bool, error) {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(user, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(user, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteRolesForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRolesForUserInDomain'
type IEnforcer_DeleteRolesForUserInDomain_Call struct {
	*mock.Call
}

// DeleteRolesForUserInDomain is a helper method to define mock.On call
//   - user string
//   - domain string
func (_e *IEnforcer_Expecter) DeleteRolesForUserInDomain(user interface{}, domain interface{}) *IEnforcer_DeleteRolesForUserInDomain_Call {
	return &IEnforcer_DeleteRolesForUserInDomain_Call{Call: _e.mock.On("DeleteRolesForUserInDomain", user, domain)}
}

func (_c *IEnforcer_DeleteRolesForUserInDomain_Call) Run(run func(user string, domain string)) *IEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IEnforcer_DeleteRolesForUserInDomain_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteRolesForUserInDomain_Call) RunAndReturn(run func(string, string) (bool, error)) *IEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: user
func (_m *IEnforcer) DeleteUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type IEnforcer_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - user string
func (_e *IEnforcer_Expecter) DeleteUser(user interface{}) *IEnforcer_DeleteUser_Call {
	return &IEnforcer_DeleteUser_Call{Call: _e.mock.On("DeleteUser", user)}
}

func (_c *IEnforcer_DeleteUser_Call) Run(run func(user string)) *IEnforcer_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_DeleteUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_DeleteUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_DeleteUser_Call) RunAndReturn(run func(string) (bool, error)) *IEnforcer_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// EnableAutoBuildRoleLinks provides a mock function with given fields: autoBuildRoleLinks
func (_m *IEnforcer) EnableAutoBuildRoleLinks(autoBuildRoleLinks bool) {
	_m.Called(autoBuildRoleLinks)
}

// IEnforcer_EnableAutoBuildRoleLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoBuildRoleLinks'
type IEnforcer_EnableAutoBuildRoleLinks_Call struct {
	*mock.Call
}

// EnableAutoBuildRoleLinks is a helper method to define mock.On call
//   - autoBuildRoleLinks bool
func (_e *IEnforcer_Expecter) EnableAutoBuildRoleLinks(autoBuildRoleLinks interface{}) *IEnforcer_EnableAutoBuildRoleLinks_Call {
	return &IEnforcer_EnableAutoBuildRoleLinks_Call{Call: _e.mock.On("EnableAutoBuildRoleLinks", autoBuildRoleLinks)}
}

func (_c *IEnforcer_EnableAutoBuildRoleLinks_Call) Run(run func(autoBuildRoleLinks bool)) *IEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *IEnforcer_EnableAutoBuildRoleLinks_Call) Return() *IEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_EnableAutoBuildRoleLinks_Call) RunAndReturn(run func(bool)) *IEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Call.Return(run)
	return _c
}

// EnableAutoNotifyWatcher provides a mock function with given fields: enable
func (_m *IEnforcer) EnableAutoNotifyWatcher(enable bool) {
	_m.Called(enable)
}

// IEnforcer_EnableAutoNotifyWatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoNotifyWatcher'
type IEnforcer_EnableAutoNotifyWatcher_Call struct {
	*mock.Call
}

// EnableAutoNotifyWatcher is a helper method to define mock.On call
//   - enable bool
func (_e *IEnforcer_Expecter) EnableAutoNotifyWatcher(enable interface{}) *IEnforcer_EnableAutoNotifyWatcher_Call {
	return &IEnforcer_EnableAutoNotifyWatcher_Call{Call: _e.mock.On("EnableAutoNotifyWatcher", enable)}
}

func (_c *IEnforcer_EnableAutoNotifyWatcher_Call) Run(run func(enable bool)) *IEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *IEnforcer_EnableAutoNotifyWatcher_Call) Return() *IEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_EnableAutoNotifyWatcher_Call) RunAndReturn(run func(bool)) *IEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Call.Return(run)
	return _c
}

// EnableAutoSave provides a mock function with given fields: autoSave
func (_m *IEnforcer) EnableAutoSave(autoSave bool) {
	_m.Called(autoSave)
}

// IEnforcer_EnableAutoSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoSave'
type IEnforcer_EnableAutoSave_Call struct {
	*mock.Call
}

// EnableAutoSave is a helper method to define mock.On call
//   - autoSave bool
func (_e *IEnforcer_Expecter) EnableAutoSave(autoSave interface{}) *IEnforcer_EnableAutoSave_Call {
	return &IEnforcer_EnableAutoSave_Call{Call: _e.mock.On("EnableAutoSave", autoSave)}
}

func (_c *IEnforcer_EnableAutoSave_Call) Run(run func(autoSave bool)) *IEnforcer_EnableAutoSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *IEnforcer_EnableAutoSave_Call) Return() *IEnforcer_EnableAutoSave_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_EnableAutoSave_Call) RunAndReturn(run func(bool)) *IEnforcer_EnableAutoSave_Call {
	_c.Call.Return(run)
	return _c
}

// EnableEnforce provides a mock function with given fields: enable
func (_m *IEnforcer) EnableEnforce(enable bool) {
	_m.Called(enable)
}

// IEnforcer_EnableEnforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableEnforce'
type IEnforcer_EnableEnforce_Call struct {
	*mock.Call
}

// EnableEnforce is a helper method to define mock.On call
//   - enable bool
func (_e *IEnforcer_Expecter) EnableEnforce(enable interface{}) *IEnforcer_EnableEnforce_Call {
	return &IEnforcer_EnableEnforce_Call{Call: _e.mock.On("EnableEnforce", enable)}
}

func (_c *IEnforcer_EnableEnforce_Call) Run(run func(enable bool)) *IEnforcer_EnableEnforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *IEnforcer_EnableEnforce_Call) Return() *IEnforcer_EnableEnforce_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_EnableEnforce_Call) RunAndReturn(run func(bool)) *IEnforcer_EnableEnforce_Call {
	_c.Call.Return(run)
	return _c
}

// EnableLog provides a mock function with given fields: enable
func (_m *IEnforcer) EnableLog(enable bool) {
	_m.Called(enable)
}

// IEnforcer_EnableLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableLog'
type IEnforcer_EnableLog_Call struct {
	*mock.Call
}

// EnableLog is a helper method to define mock.On call
//   - enable bool
func (_e *IEnforcer_Expecter) EnableLog(enable interface{}) *IEnforcer_EnableLog_Call {
	return &IEnforcer_EnableLog_Call{Call: _e.mock.On("EnableLog", enable)}
}

func (_c *IEnforcer_EnableLog_Call) Run(run func(enable bool)) *IEnforcer_EnableLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *IEnforcer_EnableLog_Call) Return() *IEnforcer_EnableLog_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_EnableLog_Call) RunAndReturn(run func(bool)) *IEnforcer_EnableLog_Call {
	_c.Call.Return(run)
	return _c
}

// Enforce provides a mock function with given fields: rvals
func (_m *IEnforcer) Enforce(rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Enforce")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_Enforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enforce'
type IEnforcer_Enforce_Call struct {
	*mock.Call
}

// Enforce is a helper method to define mock.On call
//   - rvals ...interface{}
func (_e *IEnforcer_Expecter) Enforce(rvals ...interface{}) *IEnforcer_Enforce_Call {
	return &IEnforcer_Enforce_Call{Call: _e.mock.On("Enforce",
		append([]interface{}{}, rvals...)...)}
}

func (_c *IEnforcer_Enforce_Call) Run(run func(rvals ...interface{})) *IEnforcer_Enforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_Enforce_Call) Return(_a0 bool, _a1 error) *IEnforcer_Enforce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_Enforce_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_Enforce_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceEx provides a mock function with given fields: rvals
func (_m *IEnforcer) EnforceEx(rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceEx")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, []string, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) []string); ok {
		r1 = rf(rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(...interface{}) error); ok {
		r2 = rf(rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IEnforcer_EnforceEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceEx'
type IEnforcer_EnforceEx_Call struct {
	*mock.Call
}

// EnforceEx is a helper method to define mock.On call
//   - rvals ...interface{}
func (_e *IEnforcer_Expecter) EnforceEx(rvals ...interface{}) *IEnforcer_EnforceEx_Call {
	return &IEnforcer_EnforceEx_Call{Call: _e.mock.On("EnforceEx",
		append([]interface{}{}, rvals...)...)}
}

func (_c *IEnforcer_EnforceEx_Call) Run(run func(rvals ...interface{})) *IEnforcer_EnforceEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_EnforceEx_Call) Return(_a0 bool, _a1 []string, _a2 error) *IEnforcer_EnforceEx_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IEnforcer_EnforceEx_Call) RunAndReturn(run func(...interface{}) (bool, []string, error)) *IEnforcer_EnforceEx_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceExWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *IEnforcer) EnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceExWithMatcher")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, []string, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) []string); ok {
		r1 = rf(matcher, rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(string, ...interface{}) error); ok {
		r2 = rf(matcher, rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IEnforcer_EnforceExWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceExWithMatcher'
type IEnforcer_EnforceExWithMatcher_Call struct {
	*mock.Call
}

// EnforceExWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - rvals ...interface{}
func (_e *IEnforcer_Expecter) EnforceExWithMatcher(matcher interface{}, rvals ...interface{}) *IEnforcer_EnforceExWithMatcher_Call {
	return &IEnforcer_EnforceExWithMatcher_Call{Call: _e.mock.On("EnforceExWithMatcher",
		append([]interface{}{matcher}, rvals...)...)}
}

func (_c *IEnforcer_EnforceExWithMatcher_Call) Run(run func(matcher string, rvals ...interface{})) *IEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_EnforceExWithMatcher_Call) Return(_a0 bool, _a1 []string, _a2 error) *IEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IEnforcer_EnforceExWithMatcher_Call) RunAndReturn(run func(string, ...interface{}) (bool, []string, error)) *IEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *IEnforcer) EnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceWithMatcher")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(matcher, rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_EnforceWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceWithMatcher'
type IEnforcer_EnforceWithMatcher_Call struct {
	*mock.Call
}

// EnforceWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - rvals ...interface{}
func (_e *IEnforcer_Expecter) EnforceWithMatcher(matcher interface{}, rvals ...interface{}) *IEnforcer_EnforceWithMatcher_Call {
	return &IEnforcer_EnforceWithMatcher_Call{Call: _e.mock.On("EnforceWithMatcher",
		append([]interface{}{matcher}, rvals...)...)}
}

func (_c *IEnforcer_EnforceWithMatcher_Call) Run(run func(matcher string, rvals ...interface{})) *IEnforcer_EnforceWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_EnforceWithMatcher_Call) Return(_a0 bool, _a1 error) *IEnforcer_EnforceWithMatcher_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_EnforceWithMatcher_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_EnforceWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// GetAdapter provides a mock function with given fields:
func (_m *IEnforcer) GetAdapter() persist.Adapter {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAdapter")
	}

	var r0 persist.Adapter
	if rf, ok := ret.Get(0).(func() persist.Adapter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persist.Adapter)
		}
	}

	return r0
}

// IEnforcer_GetAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAdapter'
type IEnforcer_GetAdapter_Call struct {
	*mock.Call
}

// GetAdapter is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAdapter() *IEnforcer_GetAdapter_Call {
	return &IEnforcer_GetAdapter_Call{Call: _e.mock.On("GetAdapter")}
}

func (_c *IEnforcer_GetAdapter_Call) Run(run func()) *IEnforcer_GetAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAdapter_Call) Return(_a0 persist.Adapter) *IEnforcer_GetAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetAdapter_Call) RunAndReturn(run func() persist.Adapter) *IEnforcer_GetAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllActions provides a mock function with given fields:
func (_m *IEnforcer) GetAllActions() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllActions'
type IEnforcer_GetAllActions_Call struct {
	*mock.Call
}

// GetAllActions is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAllActions() *IEnforcer_GetAllActions_Call {
	return &IEnforcer_GetAllActions_Call{Call: _e.mock.On("GetAllActions")}
}

func (_c *IEnforcer_GetAllActions_Call) Run(run func()) *IEnforcer_GetAllActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAllActions_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllActions_Call) RunAndReturn(run func() ([]string, error)) *IEnforcer_GetAllActions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllDomains provides a mock function with given fields:
func (_m *IEnforcer) GetAllDomains() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllDomains")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllDomains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllDomains'
type IEnforcer_GetAllDomains_Call struct {
	*mock.Call
}

// GetAllDomains is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAllDomains() *IEnforcer_GetAllDomains_Call {
	return &IEnforcer_GetAllDomains_Call{Call: _e.mock.On("GetAllDomains")}
}

func (_c *IEnforcer_GetAllDomains_Call) Run(run func()) *IEnforcer_GetAllDomains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAllDomains_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllDomains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllDomains_Call) RunAndReturn(run func() ([]string, error)) *IEnforcer_GetAllDomains_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedActions provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedActions(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllNamedActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedActions'
type IEnforcer_GetAllNamedActions_Call struct {
	*mock.Call
}

// GetAllNamedActions is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetAllNamedActions(ptype interface{}) *IEnforcer_GetAllNamedActions_Call {
	return &IEnforcer_GetAllNamedActions_Call{Call: _e.mock.On("GetAllNamedActions", ptype)}
}

func (_c *IEnforcer_GetAllNamedActions_Call) Run(run func(ptype string)) *IEnforcer_GetAllNamedActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllNamedActions_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllNamedActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllNamedActions_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllNamedActions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedObjects provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedObjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllNamedObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedObjects'
type IEnforcer_GetAllNamedObjects_Call struct {
	*mock.Call
}

// GetAllNamedObjects is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetAllNamedObjects(ptype interface{}) *IEnforcer_GetAllNamedObjects_Call {
	return &IEnforcer_GetAllNamedObjects_Call{Call: _e.mock.On("GetAllNamedObjects", ptype)}
}

func (_c *IEnforcer_GetAllNamedObjects_Call) Run(run func(ptype string)) *IEnforcer_GetAllNamedObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllNamedObjects_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllNamedObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllNamedObjects_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllNamedObjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedRoles provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedRoles(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllNamedRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedRoles'
type IEnforcer_GetAllNamedRoles_Call struct {
	*mock.Call
}

// GetAllNamedRoles is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetAllNamedRoles(ptype interface{}) *IEnforcer_GetAllNamedRoles_Call {
	return &IEnforcer_GetAllNamedRoles_Call{Call: _e.mock.On("GetAllNamedRoles", ptype)}
}

func (_c *IEnforcer_GetAllNamedRoles_Call) Run(run func(ptype string)) *IEnforcer_GetAllNamedRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllNamedRoles_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllNamedRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllNamedRoles_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllNamedRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedSubjects provides a mock function with given fields: ptype
func (_m *IEnforcer) GetAllNamedSubjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllNamedSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedSubjects'
type IEnforcer_GetAllNamedSubjects_Call struct {
	*mock.Call
}

// GetAllNamedSubjects is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetAllNamedSubjects(ptype interface{}) *IEnforcer_GetAllNamedSubjects_Call {
	return &IEnforcer_GetAllNamedSubjects_Call{Call: _e.mock.On("GetAllNamedSubjects", ptype)}
}

func (_c *IEnforcer_GetAllNamedSubjects_Call) Run(run func(ptype string)) *IEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllNamedSubjects_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllNamedSubjects_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllObjects provides a mock function with given fields:
func (_m *IEnforcer) GetAllObjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllObjects'
type IEnforcer_GetAllObjects_Call struct {
	*mock.Call
}

// GetAllObjects is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAllObjects() *IEnforcer_GetAllObjects_Call {
	return &IEnforcer_GetAllObjects_Call{Call: _e.mock.On("GetAllObjects")}
}

func (_c *IEnforcer_GetAllObjects_Call) Run(run func()) *IEnforcer_GetAllObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAllObjects_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllObjects_Call) RunAndReturn(run func() ([]string, error)) *IEnforcer_GetAllObjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllRoles provides a mock function with given fields:
func (_m *IEnforcer) GetAllRoles() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllRoles'
type IEnforcer_GetAllRoles_Call struct {
	*mock.Call
}

// GetAllRoles is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAllRoles() *IEnforcer_GetAllRoles_Call {
	return &IEnforcer_GetAllRoles_Call{Call: _e.mock.On("GetAllRoles")}
}

func (_c *IEnforcer_GetAllRoles_Call) Run(run func()) *IEnforcer_GetAllRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAllRoles_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllRoles_Call) RunAndReturn(run func() ([]string, error)) *IEnforcer_GetAllRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllRolesByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) GetAllRolesByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllRolesByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllRolesByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllRolesByDomain'
type IEnforcer_GetAllRolesByDomain_Call struct {
	*mock.Call
}

// GetAllRolesByDomain is a helper method to define mock.On call
//   - domain string
func (_e *IEnforcer_Expecter) GetAllRolesByDomain(domain interface{}) *IEnforcer_GetAllRolesByDomain_Call {
	return &IEnforcer_GetAllRolesByDomain_Call{Call: _e.mock.On("GetAllRolesByDomain", domain)}
}

func (_c *IEnforcer_GetAllRolesByDomain_Call) Run(run func(domain string)) *IEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllRolesByDomain_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllRolesByDomain_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllSubjects provides a mock function with given fields:
func (_m *IEnforcer) GetAllSubjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllSubjects'
type IEnforcer_GetAllSubjects_Call struct {
	*mock.Call
}

// GetAllSubjects is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetAllSubjects() *IEnforcer_GetAllSubjects_Call {
	return &IEnforcer_GetAllSubjects_Call{Call: _e.mock.On("GetAllSubjects")}
}

func (_c *IEnforcer_GetAllSubjects_Call) Run(run func()) *IEnforcer_GetAllSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetAllSubjects_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllSubjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllSubjects_Call) RunAndReturn(run func() ([]string, error)) *IEnforcer_GetAllSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUsersByDomain provides a mock function with given fields: domain
func (_m *IEnforcer) GetAllUsersByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUsersByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetAllUsersByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUsersByDomain'
type IEnforcer_GetAllUsersByDomain_Call struct {
	*mock.Call
}

// GetAllUsersByDomain is a helper method to define mock.On call
//   - domain string
func (_e *IEnforcer_Expecter) GetAllUsersByDomain(domain interface{}) *IEnforcer_GetAllUsersByDomain_Call {
	return &IEnforcer_GetAllUsersByDomain_Call{Call: _e.mock.On("GetAllUsersByDomain", domain)}
}

func (_c *IEnforcer_GetAllUsersByDomain_Call) Run(run func(domain string)) *IEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetAllUsersByDomain_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetAllUsersByDomain_Call) RunAndReturn(run func(string) ([]string, error)) *IEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetFilteredGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredGroupingPolicy'
type IEnforcer_GetFilteredGroupingPolicy_Call struct {
	*mock.Call
}

// GetFilteredGroupingPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) GetFilteredGroupingPolicy(fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_GetFilteredGroupingPolicy_Call {
	return &IEnforcer_GetFilteredGroupingPolicy_Call{Call: _e.mock.On("GetFilteredGroupingPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_GetFilteredGroupingPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *IEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetFilteredGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetFilteredGroupingPolicy_Call) RunAndReturn(run func(int, ...string) ([][]string, error)) *IEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetFilteredNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredNamedGroupingPolicy'
type IEnforcer_GetFilteredNamedGroupingPolicy_Call struct {
	*mock.Call
}

// GetFilteredNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) GetFilteredNamedGroupingPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_GetFilteredNamedGroupingPolicy_Call {
	return &IEnforcer_GetFilteredNamedGroupingPolicy_Call{Call: _e.mock.On("GetFilteredNamedGroupingPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_GetFilteredNamedGroupingPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *IEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetFilteredNamedGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetFilteredNamedGroupingPolicy_Call) RunAndReturn(run func(string, int, ...string) ([][]string, error)) *IEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetFilteredNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredNamedPolicy'
type IEnforcer_GetFilteredNamedPolicy_Call struct {
	*mock.Call
}

// GetFilteredNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) GetFilteredNamedPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_GetFilteredNamedPolicy_Call {
	return &IEnforcer_GetFilteredNamedPolicy_Call{Call: _e.mock.On("GetFilteredNamedPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_GetFilteredNamedPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *IEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetFilteredNamedPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetFilteredNamedPolicy_Call) RunAndReturn(run func(string, int, ...string) ([][]string, error)) *IEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) GetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredPolicy'
type IEnforcer_GetFilteredPolicy_Call struct {
	*mock.Call
}

// GetFilteredPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) GetFilteredPolicy(fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_GetFilteredPolicy_Call {
	return &IEnforcer_GetFilteredPolicy_Call{Call: _e.mock.On("GetFilteredPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_GetFilteredPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *IEnforcer_GetFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetFilteredPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetFilteredPolicy_Call) RunAndReturn(run func(int, ...string) ([][]string, error)) *IEnforcer_GetFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupingPolicy provides a mock function with given fields:
func (_m *IEnforcer) GetGroupingPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupingPolicy'
type IEnforcer_GetGroupingPolicy_Call struct {
	*mock.Call
}

// GetGroupingPolicy is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetGroupingPolicy() *IEnforcer_GetGroupingPolicy_Call {
	return &IEnforcer_GetGroupingPolicy_Call{Call: _e.mock.On("GetGroupingPolicy")}
}

func (_c *IEnforcer_GetGroupingPolicy_Call) Run(run func()) *IEnforcer_GetGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetGroupingPolicy_Call) RunAndReturn(run func() ([][]string, error)) *IEnforcer_GetGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitPermissionsForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetImplicitPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitPermissionsForUser'
type IEnforcer_GetImplicitPermissionsForUser_Call struct {
	*mock.Call
}

// GetImplicitPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *IEnforcer_Expecter) GetImplicitPermissionsForUser(user interface{}, domain ...interface{}) *IEnforcer_GetImplicitPermissionsForUser_Call {
	return &IEnforcer_GetImplicitPermissionsForUser_Call{Call: _e.mock.On("GetImplicitPermissionsForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *IEnforcer_GetImplicitPermissionsForUser_Call) Run(run func(user string, domain ...string)) *IEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetImplicitPermissionsForUser_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetImplicitPermissionsForUser_Call) RunAndReturn(run func(string, ...string) ([][]string, error)) *IEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitRolesForUser provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetImplicitRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetImplicitRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitRolesForUser'
type IEnforcer_GetImplicitRolesForUser_Call struct {
	*mock.Call
}

// GetImplicitRolesForUser is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *IEnforcer_Expecter) GetImplicitRolesForUser(name interface{}, domain ...interface{}) *IEnforcer_GetImplicitRolesForUser_Call {
	return &IEnforcer_GetImplicitRolesForUser_Call{Call: _e.mock.On("GetImplicitRolesForUser",
		append([]interface{}{name}, domain...)...)}
}

func (_c *IEnforcer_GetImplicitRolesForUser_Call) Run(run func(name string, domain ...string)) *IEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetImplicitRolesForUser_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetImplicitRolesForUser_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *IEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitUsersForPermission provides a mock function with given fields: permission
func (_m *IEnforcer) GetImplicitUsersForPermission(permission ...string) ([]string, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitUsersForPermission")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) ([]string, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) []string); ok {
		r0 = rf(permission...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetImplicitUsersForPermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitUsersForPermission'
type IEnforcer_GetImplicitUsersForPermission_Call struct {
	*mock.Call
}

// GetImplicitUsersForPermission is a helper method to define mock.On call
//   - permission ...string
func (_e *IEnforcer_Expecter) GetImplicitUsersForPermission(permission ...interface{}) *IEnforcer_GetImplicitUsersForPermission_Call {
	return &IEnforcer_GetImplicitUsersForPermission_Call{Call: _e.mock.On("GetImplicitUsersForPermission",
		append([]interface{}{}, permission...)...)}
}

func (_c *IEnforcer_GetImplicitUsersForPermission_Call) Run(run func(permission ...string)) *IEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetImplicitUsersForPermission_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetImplicitUsersForPermission_Call) RunAndReturn(run func(...string) ([]string, error)) *IEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Return(run)
	return _c
}

// GetModel provides a mock function with given fields:
func (_m *IEnforcer) GetModel() model.Model {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetModel")
	}

	var r0 model.Model
	if rf, ok := ret.Get(0).(func() model.Model); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.Model)
		}
	}

	return r0
}

// IEnforcer_GetModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetModel'
type IEnforcer_GetModel_Call struct {
	*mock.Call
}

// GetModel is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetModel() *IEnforcer_GetModel_Call {
	return &IEnforcer_GetModel_Call{Call: _e.mock.On("GetModel")}
}

func (_c *IEnforcer_GetModel_Call) Run(run func()) *IEnforcer_GetModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetModel_Call) Return(_a0 model.Model) *IEnforcer_GetModel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetModel_Call) RunAndReturn(run func() model.Model) *IEnforcer_GetModel_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamedGroupingPolicy provides a mock function with given fields: ptype
func (_m *IEnforcer) GetNamedGroupingPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamedGroupingPolicy'
type IEnforcer_GetNamedGroupingPolicy_Call struct {
	*mock.Call
}

// GetNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetNamedGroupingPolicy(ptype interface{}) *IEnforcer_GetNamedGroupingPolicy_Call {
	return &IEnforcer_GetNamedGroupingPolicy_Call{Call: _e.mock.On("GetNamedGroupingPolicy", ptype)}
}

func (_c *IEnforcer_GetNamedGroupingPolicy_Call) Run(run func(ptype string)) *IEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetNamedGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetNamedGroupingPolicy_Call) RunAndReturn(run func(string) ([][]string, error)) *IEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamedPolicy provides a mock function with given fields: ptype
func (_m *IEnforcer) GetNamedPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamedPolicy'
type IEnforcer_GetNamedPolicy_Call struct {
	*mock.Call
}

// GetNamedPolicy is a helper method to define mock.On call
//   - ptype string
func (_e *IEnforcer_Expecter) GetNamedPolicy(ptype interface{}) *IEnforcer_GetNamedPolicy_Call {
	return &IEnforcer_GetNamedPolicy_Call{Call: _e.mock.On("GetNamedPolicy", ptype)}
}

func (_c *IEnforcer_GetNamedPolicy_Call) Run(run func(ptype string)) *IEnforcer_GetNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IEnforcer_GetNamedPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetNamedPolicy_Call) RunAndReturn(run func(string) ([][]string, error)) *IEnforcer_GetNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsForUser provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsForUser'
type IEnforcer_GetPermissionsForUser_Call struct {
	*mock.Call
}

// GetPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *IEnforcer_Expecter) GetPermissionsForUser(user interface{}, domain ...interface{}) *IEnforcer_GetPermissionsForUser_Call {
	return &IEnforcer_GetPermissionsForUser_Call{Call: _e.mock.On("GetPermissionsForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *IEnforcer_GetPermissionsForUser_Call) Run(run func(user string, domain ...string)) *IEnforcer_GetPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetPermissionsForUser_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetPermissionsForUser_Call) RunAndReturn(run func(string, ...string) ([][]string, error)) *IEnforcer_GetPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsForUserInDomain provides a mock function with given fields: user, domain
func (_m *IEnforcer) GetPermissionsForUserInDomain(user string, domain string) [][]string {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUserInDomain")
	}

	var r0 [][]string
	if rf, ok := ret.Get(0).(func(string, string) [][]string); ok {
		r0 = rf(user, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	return r0
}

// IEnforcer_GetPermissionsForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsForUserInDomain'
type IEnforcer_GetPermissionsForUserInDomain_Call struct {
	*mock.Call
}

// GetPermissionsForUserInDomain is a helper method to define mock.On call
//   - user string
//   - domain string
func (_e *IEnforcer_Expecter) GetPermissionsForUserInDomain(user interface{}, domain interface{}) *IEnforcer_GetPermissionsForUserInDomain_Call {
	return &IEnforcer_GetPermissionsForUserInDomain_Call{Call: _e.mock.On("GetPermissionsForUserInDomain", user, domain)}
}

func (_c *IEnforcer_GetPermissionsForUserInDomain_Call) Run(run func(user string, domain string)) *IEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IEnforcer_GetPermissionsForUserInDomain_Call) Return(_a0 [][]string) *IEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetPermissionsForUserInDomain_Call) RunAndReturn(run func(string, string) [][]string) *IEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicy provides a mock function with given fields:
func (_m *IEnforcer) GetPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicy'
type IEnforcer_GetPolicy_Call struct {
	*mock.Call
}

// GetPolicy is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetPolicy() *IEnforcer_GetPolicy_Call {
	return &IEnforcer_GetPolicy_Call{Call: _e.mock.On("GetPolicy")}
}

func (_c *IEnforcer_GetPolicy_Call) Run(run func()) *IEnforcer_GetPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetPolicy_Call) Return(_a0 [][]string, _a1 error) *IEnforcer_GetPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetPolicy_Call) RunAndReturn(run func() ([][]string, error)) *IEnforcer_GetPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleManager provides a mock function with given fields:
func (_m *IEnforcer) GetRoleManager() rbac.RoleManager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRoleManager")
	}

	var r0 rbac.RoleManager
	if rf, ok := ret.Get(0).(func() rbac.RoleManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rbac.RoleManager)
		}
	}

	return r0
}

// IEnforcer_GetRoleManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleManager'
type IEnforcer_GetRoleManager_Call struct {
	*mock.Call
}

// GetRoleManager is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) GetRoleManager() *IEnforcer_GetRoleManager_Call {
	return &IEnforcer_GetRoleManager_Call{Call: _e.mock.On("GetRoleManager")}
}

func (_c *IEnforcer_GetRoleManager_Call) Run(run func()) *IEnforcer_GetRoleManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_GetRoleManager_Call) Return(_a0 rbac.RoleManager) *IEnforcer_GetRoleManager_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetRoleManager_Call) RunAndReturn(run func() rbac.RoleManager) *IEnforcer_GetRoleManager_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesForUser provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesForUser'
type IEnforcer_GetRolesForUser_Call struct {
	*mock.Call
}

// GetRolesForUser is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *IEnforcer_Expecter) GetRolesForUser(name interface{}, domain ...interface{}) *IEnforcer_GetRolesForUser_Call {
	return &IEnforcer_GetRolesForUser_Call{Call: _e.mock.On("GetRolesForUser",
		append([]interface{}{name}, domain...)...)}
}

func (_c *IEnforcer_GetRolesForUser_Call) Run(run func(name string, domain ...string)) *IEnforcer_GetRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetRolesForUser_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetRolesForUser_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *IEnforcer_GetRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesForUserInDomain provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetRolesForUserInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUserInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// IEnforcer_GetRolesForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesForUserInDomain'
type IEnforcer_GetRolesForUserInDomain_Call struct {
	*mock.Call
}

// GetRolesForUserInDomain is a helper method to define mock.On call
//   - name string
//   - domain string
func (_e *IEnforcer_Expecter) GetRolesForUserInDomain(name interface{}, domain interface{}) *IEnforcer_GetRolesForUserInDomain_Call {
	return &IEnforcer_GetRolesForUserInDomain_Call{Call: _e.mock.On("GetRolesForUserInDomain", name, domain)}
}

func (_c *IEnforcer_GetRolesForUserInDomain_Call) Run(run func(name string, domain string)) *IEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IEnforcer_GetRolesForUserInDomain_Call) Return(_a0 []string) *IEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetRolesForUserInDomain_Call) RunAndReturn(run func(string, string) []string) *IEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersForRole provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetUsersForRole(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRole")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_GetUsersForRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersForRole'
type IEnforcer_GetUsersForRole_Call struct {
	*mock.Call
}

// GetUsersForRole is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *IEnforcer_Expecter) GetUsersForRole(name interface{}, domain ...interface{}) *IEnforcer_GetUsersForRole_Call {
	return &IEnforcer_GetUsersForRole_Call{Call: _e.mock.On("GetUsersForRole",
		append([]interface{}{name}, domain...)...)}
}

func (_c *IEnforcer_GetUsersForRole_Call) Run(run func(name string, domain ...string)) *IEnforcer_GetUsersForRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_GetUsersForRole_Call) Return(_a0 []string, _a1 error) *IEnforcer_GetUsersForRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_GetUsersForRole_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *IEnforcer_GetUsersForRole_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersForRoleInDomain provides a mock function with given fields: name, domain
func (_m *IEnforcer) GetUsersForRoleInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRoleInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// IEnforcer_GetUsersForRoleInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersForRoleInDomain'
type IEnforcer_GetUsersForRoleInDomain_Call struct {
	*mock.Call
}

// GetUsersForRoleInDomain is a helper method to define mock.On call
//   - name string
//   - domain string
func (_e *IEnforcer_Expecter) GetUsersForRoleInDomain(name interface{}, domain interface{}) *IEnforcer_GetUsersForRoleInDomain_Call {
	return &IEnforcer_GetUsersForRoleInDomain_Call{Call: _e.mock.On("GetUsersForRoleInDomain", name, domain)}
}

func (_c *IEnforcer_GetUsersForRoleInDomain_Call) Run(run func(name string, domain string)) *IEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IEnforcer_GetUsersForRoleInDomain_Call) Return(_a0 []string) *IEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_GetUsersForRoleInDomain_Call) RunAndReturn(run func(string, string) []string) *IEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// HasGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) HasGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasGroupingPolicy'
type IEnforcer_HasGroupingPolicy_Call struct {
	*mock.Call
}

// HasGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) HasGroupingPolicy(params ...interface{}) *IEnforcer_HasGroupingPolicy_Call {
	return &IEnforcer_HasGroupingPolicy_Call{Call: _e.mock.On("HasGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_HasGroupingPolicy_Call) Run(run func(params ...interface{})) *IEnforcer_HasGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_HasGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) HasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasNamedGroupingPolicy'
type IEnforcer_HasNamedGroupingPolicy_Call struct {
	*mock.Call
}

// HasNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) HasNamedGroupingPolicy(ptype interface{}, params ...interface{}) *IEnforcer_HasNamedGroupingPolicy_Call {
	return &IEnforcer_HasNamedGroupingPolicy_Call{Call: _e.mock.On("HasNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_HasNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) HasNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasNamedPolicy'
type IEnforcer_HasNamedPolicy_Call struct {
	*mock.Call
}

// HasNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) HasNamedPolicy(ptype interface{}, params ...interface{}) *IEnforcer_HasNamedPolicy_Call {
	return &IEnforcer_HasNamedPolicy_Call{Call: _e.mock.On("HasNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_HasNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_HasNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasNamedPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_HasNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasPermissionForUser provides a mock function with given fields: user, permission
func (_m *IEnforcer) HasPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasPermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasPermissionForUser'
type IEnforcer_HasPermissionForUser_Call struct {
	*mock.Call
}

// HasPermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *IEnforcer_Expecter) HasPermissionForUser(user interface{}, permission ...interface{}) *IEnforcer_HasPermissionForUser_Call {
	return &IEnforcer_HasPermissionForUser_Call{Call: _e.mock.On("HasPermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *IEnforcer_HasPermissionForUser_Call) Run(run func(user string, permission ...string)) *IEnforcer_HasPermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasPermissionForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasPermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasPermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *IEnforcer_HasPermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// HasPolicy provides a mock function with given fields: params
func (_m *IEnforcer) HasPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasPolicy'
type IEnforcer_HasPolicy_Call struct {
	*mock.Call
}

// HasPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) HasPolicy(params ...interface{}) *IEnforcer_HasPolicy_Call {
	return &IEnforcer_HasPolicy_Call{Call: _e.mock.On("HasPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_HasPolicy_Call) Run(run func(params ...interface{})) *IEnforcer_HasPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_HasPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasRoleForUser provides a mock function with given fields: name, role, domain
func (_m *IEnforcer) HasRoleForUser(name string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(name, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(name, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(name, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_HasRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasRoleForUser'
type IEnforcer_HasRoleForUser_Call struct {
	*mock.Call
}

// HasRoleForUser is a helper method to define mock.On call
//   - name string
//   - role string
//   - domain ...string
func (_e *IEnforcer_Expecter) HasRoleForUser(name interface{}, role interface{}, domain ...interface{}) *IEnforcer_HasRoleForUser_Call {
	return &IEnforcer_HasRoleForUser_Call{Call: _e.mock.On("HasRoleForUser",
		append([]interface{}{name, role}, domain...)...)}
}

func (_c *IEnforcer_HasRoleForUser_Call) Run(run func(name string, role string, domain ...string)) *IEnforcer_HasRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_HasRoleForUser_Call) Return(_a0 bool, _a1 error) *IEnforcer_HasRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_HasRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *IEnforcer_HasRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithAdapter provides a mock function with given fields: modelPath, adapter
func (_m *IEnforcer) InitWithAdapter(modelPath string, adapter persist.Adapter) error {
	ret := _m.Called(modelPath, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, persist.Adapter) error); ok {
		r0 = rf(modelPath, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_InitWithAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithAdapter'
type IEnforcer_InitWithAdapter_Call struct {
	*mock.Call
}

// InitWithAdapter is a helper method to define mock.On call
//   - modelPath string
//   - adapter persist.Adapter
func (_e *IEnforcer_Expecter) InitWithAdapter(modelPath interface{}, adapter interface{}) *IEnforcer_InitWithAdapter_Call {
	return &IEnforcer_InitWithAdapter_Call{Call: _e.mock.On("InitWithAdapter", modelPath, adapter)}
}

func (_c *IEnforcer_InitWithAdapter_Call) Run(run func(modelPath string, adapter persist.Adapter)) *IEnforcer_InitWithAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(persist.Adapter))
	})
	return _c
}

func (_c *IEnforcer_InitWithAdapter_Call) Return(_a0 error) *IEnforcer_InitWithAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_InitWithAdapter_Call) RunAndReturn(run func(string, persist.Adapter) error) *IEnforcer_InitWithAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithFile provides a mock function with given fields: modelPath, policyPath
func (_m *IEnforcer) InitWithFile(modelPath string, policyPath string) error {
	ret := _m.Called(modelPath, policyPath)

	if len(ret) == 0 {
		panic("no return value specified for InitWithFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(modelPath, policyPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_InitWithFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithFile'
type IEnforcer_InitWithFile_Call struct {
	*mock.Call
}

// InitWithFile is a helper method to define mock.On call
//   - modelPath string
//   - policyPath string
func (_e *IEnforcer_Expecter) InitWithFile(modelPath interface{}, policyPath interface{}) *IEnforcer_InitWithFile_Call {
	return &IEnforcer_InitWithFile_Call{Call: _e.mock.On("InitWithFile", modelPath, policyPath)}
}

func (_c *IEnforcer_InitWithFile_Call) Run(run func(modelPath string, policyPath string)) *IEnforcer_InitWithFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IEnforcer_InitWithFile_Call) Return(_a0 error) *IEnforcer_InitWithFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_InitWithFile_Call) RunAndReturn(run func(string, string) error) *IEnforcer_InitWithFile_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithModelAndAdapter provides a mock function with given fields: m, adapter
func (_m *IEnforcer) InitWithModelAndAdapter(m model.Model, adapter persist.Adapter) error {
	ret := _m.Called(m, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithModelAndAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Model, persist.Adapter) error); ok {
		r0 = rf(m, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_InitWithModelAndAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithModelAndAdapter'
type IEnforcer_InitWithModelAndAdapter_Call struct {
	*mock.Call
}

// InitWithModelAndAdapter is a helper method to define mock.On call
//   - m model.Model
//   - adapter persist.Adapter
func (_e *IEnforcer_Expecter) InitWithModelAndAdapter(m interface{}, adapter interface{}) *IEnforcer_InitWithModelAndAdapter_Call {
	return &IEnforcer_InitWithModelAndAdapter_Call{Call: _e.mock.On("InitWithModelAndAdapter", m, adapter)}
}

func (_c *IEnforcer_InitWithModelAndAdapter_Call) Run(run func(m model.Model, adapter persist.Adapter)) *IEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Model), args[1].(persist.Adapter))
	})
	return _c
}

func (_c *IEnforcer_InitWithModelAndAdapter_Call) Return(_a0 error) *IEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_InitWithModelAndAdapter_Call) RunAndReturn(run func(model.Model, persist.Adapter) error) *IEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// IsFiltered provides a mock function with given fields:
func (_m *IEnforcer) IsFiltered() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsFiltered")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IEnforcer_IsFiltered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsFiltered'
type IEnforcer_IsFiltered_Call struct {
	*mock.Call
}

// IsFiltered is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) IsFiltered() *IEnforcer_IsFiltered_Call {
	return &IEnforcer_IsFiltered_Call{Call: _e.mock.On("IsFiltered")}
}

func (_c *IEnforcer_IsFiltered_Call) Run(run func()) *IEnforcer_IsFiltered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_IsFiltered_Call) Return(_a0 bool) *IEnforcer_IsFiltered_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_IsFiltered_Call) RunAndReturn(run func() bool) *IEnforcer_IsFiltered_Call {
	_c.Call.Return(run)
	return _c
}

// LoadFilteredPolicy provides a mock function with given fields: filter
func (_m *IEnforcer) LoadFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_LoadFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadFilteredPolicy'
type IEnforcer_LoadFilteredPolicy_Call struct {
	*mock.Call
}

// LoadFilteredPolicy is a helper method to define mock.On call
//   - filter interface{}
func (_e *IEnforcer_Expecter) LoadFilteredPolicy(filter interface{}) *IEnforcer_LoadFilteredPolicy_Call {
	return &IEnforcer_LoadFilteredPolicy_Call{Call: _e.mock.On("LoadFilteredPolicy", filter)}
}

func (_c *IEnforcer_LoadFilteredPolicy_Call) Run(run func(filter interface{})) *IEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *IEnforcer_LoadFilteredPolicy_Call) Return(_a0 error) *IEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_LoadFilteredPolicy_Call) RunAndReturn(run func(interface{}) error) *IEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// LoadIncrementalFilteredPolicy provides a mock function with given fields: filter
func (_m *IEnforcer) LoadIncrementalFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadIncrementalFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_LoadIncrementalFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadIncrementalFilteredPolicy'
type IEnforcer_LoadIncrementalFilteredPolicy_Call struct {
	*mock.Call
}

// LoadIncrementalFilteredPolicy is a helper method to define mock.On call
//   - filter interface{}
func (_e *IEnforcer_Expecter) LoadIncrementalFilteredPolicy(filter interface{}) *IEnforcer_LoadIncrementalFilteredPolicy_Call {
	return &IEnforcer_LoadIncrementalFilteredPolicy_Call{Call: _e.mock.On("LoadIncrementalFilteredPolicy", filter)}
}

func (_c *IEnforcer_LoadIncrementalFilteredPolicy_Call) Run(run func(filter interface{})) *IEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *IEnforcer_LoadIncrementalFilteredPolicy_Call) Return(_a0 error) *IEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_LoadIncrementalFilteredPolicy_Call) RunAndReturn(run func(interface{}) error) *IEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// LoadModel provides a mock function with given fields:
func (_m *IEnforcer) LoadModel() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadModel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_LoadModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadModel'
type IEnforcer_LoadModel_Call struct {
	*mock.Call
}

// LoadModel is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) LoadModel() *IEnforcer_LoadModel_Call {
	return &IEnforcer_LoadModel_Call{Call: _e.mock.On("LoadModel")}
}

func (_c *IEnforcer_LoadModel_Call) Run(run func()) *IEnforcer_LoadModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_LoadModel_Call) Return(_a0 error) *IEnforcer_LoadModel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_LoadModel_Call) RunAndReturn(run func() error) *IEnforcer_LoadModel_Call {
	_c.Call.Return(run)
	return _c
}

// LoadPolicy provides a mock function with given fields:
func (_m *IEnforcer) LoadPolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_LoadPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadPolicy'
type IEnforcer_LoadPolicy_Call struct {
	*mock.Call
}

// LoadPolicy is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) LoadPolicy() *IEnforcer_LoadPolicy_Call {
	return &IEnforcer_LoadPolicy_Call{Call: _e.mock.On("LoadPolicy")}
}

func (_c *IEnforcer_LoadPolicy_Call) Run(run func()) *IEnforcer_LoadPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_LoadPolicy_Call) Return(_a0 error) *IEnforcer_LoadPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_LoadPolicy_Call) RunAndReturn(run func() error) *IEnforcer_LoadPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveFilteredGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredGroupingPolicy'
type IEnforcer_RemoveFilteredGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredGroupingPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) RemoveFilteredGroupingPolicy(fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_RemoveFilteredGroupingPolicy_Call {
	return &IEnforcer_RemoveFilteredGroupingPolicy_Call{Call: _e.mock.On("RemoveFilteredGroupingPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_RemoveFilteredGroupingPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *IEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveFilteredGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveFilteredGroupingPolicy_Call) RunAndReturn(run func(int, ...string) (bool, error)) *IEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveFilteredNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredNamedGroupingPolicy'
type IEnforcer_RemoveFilteredNamedGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) RemoveFilteredNamedGroupingPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	return &IEnforcer_RemoveFilteredNamedGroupingPolicy_Call{Call: _e.mock.On("RemoveFilteredNamedGroupingPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call) RunAndReturn(run func(string, int, ...string) (bool, error)) *IEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveFilteredNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredNamedPolicy'
type IEnforcer_RemoveFilteredNamedPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) RemoveFilteredNamedPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_RemoveFilteredNamedPolicy_Call {
	return &IEnforcer_RemoveFilteredNamedPolicy_Call{Call: _e.mock.On("RemoveFilteredNamedPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_RemoveFilteredNamedPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *IEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveFilteredNamedPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveFilteredNamedPolicy_Call) RunAndReturn(run func(string, int, ...string) (bool, error)) *IEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *IEnforcer) RemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredPolicy'
type IEnforcer_RemoveFilteredPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) RemoveFilteredPolicy(fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_RemoveFilteredPolicy_Call {
	return &IEnforcer_RemoveFilteredPolicy_Call{Call: _e.mock.On("RemoveFilteredPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_RemoveFilteredPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *IEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveFilteredPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveFilteredPolicy_Call) RunAndReturn(run func(int, ...string) (bool, error)) *IEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveGroupingPolicies provides a mock function with given fields: rules
func (_m *IEnforcer) RemoveGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveGroupingPolicies'
type IEnforcer_RemoveGroupingPolicies_Call struct {
	*mock.Call
}

// RemoveGroupingPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) RemoveGroupingPolicies(rules interface{}) *IEnforcer_RemoveGroupingPolicies_Call {
	return &IEnforcer_RemoveGroupingPolicies_Call{Call: _e.mock.On("RemoveGroupingPolicies", rules)}
}

func (_c *IEnforcer_RemoveGroupingPolicies_Call) Run(run func(rules [][]string)) *IEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_RemoveGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveGroupingPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveGroupingPolicy provides a mock function with given fields: params
func (_m *IEnforcer) RemoveGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveGroupingPolicy'
type IEnforcer_RemoveGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) RemoveGroupingPolicy(params ...interface{}) *IEnforcer_RemoveGroupingPolicy_Call {
	return &IEnforcer_RemoveGroupingPolicy_Call{Call: _e.mock.On("RemoveGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_RemoveGroupingPolicy_Call) Run(run func(params ...interface{})) *IEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) RemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedGroupingPolicies'
type IEnforcer_RemoveNamedGroupingPolicies_Call struct {
	*mock.Call
}

// RemoveNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) RemoveNamedGroupingPolicies(ptype interface{}, rules interface{}) *IEnforcer_RemoveNamedGroupingPolicies_Call {
	return &IEnforcer_RemoveNamedGroupingPolicies_Call{Call: _e.mock.On("RemoveNamedGroupingPolicies", ptype, rules)}
}

func (_c *IEnforcer_RemoveNamedGroupingPolicies_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_RemoveNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) RemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedGroupingPolicy'
type IEnforcer_RemoveNamedGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) RemoveNamedGroupingPolicy(ptype interface{}, params ...interface{}) *IEnforcer_RemoveNamedGroupingPolicy_Call {
	return &IEnforcer_RemoveNamedGroupingPolicy_Call{Call: _e.mock.On("RemoveNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_RemoveNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *IEnforcer) RemoveNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveNamedPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedPolicies'
type IEnforcer_RemoveNamedPolicies_Call struct {
	*mock.Call
}

// RemoveNamedPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) RemoveNamedPolicies(ptype interface{}, rules interface{}) *IEnforcer_RemoveNamedPolicies_Call {
	return &IEnforcer_RemoveNamedPolicies_Call{Call: _e.mock.On("RemoveNamedPolicies", ptype, rules)}
}

func (_c *IEnforcer_RemoveNamedPolicies_Call) Run(run func(ptype string, rules [][]string)) *IEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_RemoveNamedPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveNamedPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *IEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedPolicy provides a mock function with given fields: ptype, params
func (_m *IEnforcer) RemoveNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemoveNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedPolicy'
type IEnforcer_RemoveNamedPolicy_Call struct {
	*mock.Call
}

// RemoveNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *IEnforcer_Expecter) RemoveNamedPolicy(ptype interface{}, params ...interface{}) *IEnforcer_RemoveNamedPolicy_Call {
	return &IEnforcer_RemoveNamedPolicy_Call{Call: _e.mock.On("RemoveNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *IEnforcer_RemoveNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *IEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemoveNamedPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemoveNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *IEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePolicies provides a mock function with given fields: rules
func (_m *IEnforcer) RemovePolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemovePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePolicies'
type IEnforcer_RemovePolicies_Call struct {
	*mock.Call
}

// RemovePolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *IEnforcer_Expecter) RemovePolicies(rules interface{}) *IEnforcer_RemovePolicies_Call {
	return &IEnforcer_RemovePolicies_Call{Call: _e.mock.On("RemovePolicies", rules)}
}

func (_c *IEnforcer_RemovePolicies_Call) Run(run func(rules [][]string)) *IEnforcer_RemovePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *IEnforcer_RemovePolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemovePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemovePolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *IEnforcer_RemovePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePolicy provides a mock function with given fields: params
func (_m *IEnforcer) RemovePolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_RemovePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePolicy'
type IEnforcer_RemovePolicy_Call struct {
	*mock.Call
}

// RemovePolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *IEnforcer_Expecter) RemovePolicy(params ...interface{}) *IEnforcer_RemovePolicy_Call {
	return &IEnforcer_RemovePolicy_Call{Call: _e.mock.On("RemovePolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *IEnforcer_RemovePolicy_Call) Run(run func(params ...interface{})) *IEnforcer_RemovePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_RemovePolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_RemovePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_RemovePolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *IEnforcer_RemovePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SavePolicy provides a mock function with given fields:
func (_m *IEnforcer) SavePolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SavePolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_SavePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SavePolicy'
type IEnforcer_SavePolicy_Call struct {
	*mock.Call
}

// SavePolicy is a helper method to define mock.On call
func (_e *IEnforcer_Expecter) SavePolicy() *IEnforcer_SavePolicy_Call {
	return &IEnforcer_SavePolicy_Call{Call: _e.mock.On("SavePolicy")}
}

func (_c *IEnforcer_SavePolicy_Call) Run(run func()) *IEnforcer_SavePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IEnforcer_SavePolicy_Call) Return(_a0 error) *IEnforcer_SavePolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_SavePolicy_Call) RunAndReturn(run func() error) *IEnforcer_SavePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPolicies provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfAddPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPolicies'
type IEnforcer_SelfAddPolicies_Call struct {
	*mock.Call
}

// SelfAddPolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) SelfAddPolicies(sec interface{}, ptype interface{}, rules interface{}) *IEnforcer_SelfAddPolicies_Call {
	return &IEnforcer_SelfAddPolicies_Call{Call: _e.mock.On("SelfAddPolicies", sec, ptype, rules)}
}

func (_c *IEnforcer_SelfAddPolicies_Call) Run(run func(sec string, ptype string, rules [][]string)) *IEnforcer_SelfAddPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *IEnforcer_SelfAddPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfAddPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfAddPolicies_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *IEnforcer_SelfAddPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPoliciesEx provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfAddPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPoliciesEx'
type IEnforcer_SelfAddPoliciesEx_Call struct {
	*mock.Call
}

// SelfAddPoliciesEx is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) SelfAddPoliciesEx(sec interface{}, ptype interface{}, rules interface{}) *IEnforcer_SelfAddPoliciesEx_Call {
	return &IEnforcer_SelfAddPoliciesEx_Call{Call: _e.mock.On("SelfAddPoliciesEx", sec, ptype, rules)}
}

func (_c *IEnforcer_SelfAddPoliciesEx_Call) Run(run func(sec string, ptype string, rules [][]string)) *IEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *IEnforcer_SelfAddPoliciesEx_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfAddPoliciesEx_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *IEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPolicy provides a mock function with given fields: sec, ptype, rule
func (_m *IEnforcer) SelfAddPolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfAddPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPolicy'
type IEnforcer_SelfAddPolicy_Call struct {
	*mock.Call
}

// SelfAddPolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rule []string
func (_e *IEnforcer_Expecter) SelfAddPolicy(sec interface{}, ptype interface{}, rule interface{}) *IEnforcer_SelfAddPolicy_Call {
	return &IEnforcer_SelfAddPolicy_Call{Call: _e.mock.On("SelfAddPolicy", sec, ptype, rule)}
}

func (_c *IEnforcer_SelfAddPolicy_Call) Run(run func(sec string, ptype string, rule []string)) *IEnforcer_SelfAddPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *IEnforcer_SelfAddPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfAddPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfAddPolicy_Call) RunAndReturn(run func(string, string, []string) (bool, error)) *IEnforcer_SelfAddPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemoveFilteredPolicy provides a mock function with given fields: sec, ptype, fieldIndex, fieldValues
func (_m *IEnforcer) SelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, sec, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) (bool, error)); ok {
		return rf(sec, ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) bool); ok {
		r0 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, int, ...string) error); ok {
		r1 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfRemoveFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemoveFilteredPolicy'
type IEnforcer_SelfRemoveFilteredPolicy_Call struct {
	*mock.Call
}

// SelfRemoveFilteredPolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) SelfRemoveFilteredPolicy(sec interface{}, ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_SelfRemoveFilteredPolicy_Call {
	return &IEnforcer_SelfRemoveFilteredPolicy_Call{Call: _e.mock.On("SelfRemoveFilteredPolicy",
		append([]interface{}{sec, ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_SelfRemoveFilteredPolicy_Call) Run(run func(sec string, ptype string, fieldIndex int, fieldValues ...string)) *IEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_SelfRemoveFilteredPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfRemoveFilteredPolicy_Call) RunAndReturn(run func(string, string, int, ...string) (bool, error)) *IEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemovePolicies provides a mock function with given fields: sec, ptype, rules
func (_m *IEnforcer) SelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfRemovePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemovePolicies'
type IEnforcer_SelfRemovePolicies_Call struct {
	*mock.Call
}

// SelfRemovePolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *IEnforcer_Expecter) SelfRemovePolicies(sec interface{}, ptype interface{}, rules interface{}) *IEnforcer_SelfRemovePolicies_Call {
	return &IEnforcer_SelfRemovePolicies_Call{Call: _e.mock.On("SelfRemovePolicies", sec, ptype, rules)}
}

func (_c *IEnforcer_SelfRemovePolicies_Call) Run(run func(sec string, ptype string, rules [][]string)) *IEnforcer_SelfRemovePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *IEnforcer_SelfRemovePolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfRemovePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfRemovePolicies_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *IEnforcer_SelfRemovePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemovePolicy provides a mock function with given fields: sec, ptype, rule
func (_m *IEnforcer) SelfRemovePolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfRemovePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemovePolicy'
type IEnforcer_SelfRemovePolicy_Call struct {
	*mock.Call
}

// SelfRemovePolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rule []string
func (_e *IEnforcer_Expecter) SelfRemovePolicy(sec interface{}, ptype interface{}, rule interface{}) *IEnforcer_SelfRemovePolicy_Call {
	return &IEnforcer_SelfRemovePolicy_Call{Call: _e.mock.On("SelfRemovePolicy", sec, ptype, rule)}
}

func (_c *IEnforcer_SelfRemovePolicy_Call) Run(run func(sec string, ptype string, rule []string)) *IEnforcer_SelfRemovePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *IEnforcer_SelfRemovePolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfRemovePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfRemovePolicy_Call) RunAndReturn(run func(string, string, []string) (bool, error)) *IEnforcer_SelfRemovePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfUpdatePolicies provides a mock function with given fields: sec, ptype, oldRules, newRules
func (_m *IEnforcer) SelfUpdatePolicies(sec string, ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) bool); ok {
		r0 = rf(sec, ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string, [][]string) error); ok {
		r1 = rf(sec, ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfUpdatePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfUpdatePolicies'
type IEnforcer_SelfUpdatePolicies_Call struct {
	*mock.Call
}

// SelfUpdatePolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - oldRules [][]string
//   - newRules [][]string
func (_e *IEnforcer_Expecter) SelfUpdatePolicies(sec interface{}, ptype interface{}, oldRules interface{}, newRules interface{}) *IEnforcer_SelfUpdatePolicies_Call {
	return &IEnforcer_SelfUpdatePolicies_Call{Call: _e.mock.On("SelfUpdatePolicies", sec, ptype, oldRules, newRules)}
}

func (_c *IEnforcer_SelfUpdatePolicies_Call) Run(run func(sec string, ptype string, oldRules [][]string, newRules [][]string)) *IEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string), args[3].([][]string))
	})
	return _c
}

func (_c *IEnforcer_SelfUpdatePolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfUpdatePolicies_Call) RunAndReturn(run func(string, string, [][]string, [][]string) (bool, error)) *IEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfUpdatePolicy provides a mock function with given fields: sec, ptype, oldRule, newRule
func (_m *IEnforcer) SelfUpdatePolicy(sec string, ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) (bool, error)); ok {
		return rf(sec, ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) bool); ok {
		r0 = rf(sec, ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string, []string) error); ok {
		r1 = rf(sec, ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_SelfUpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfUpdatePolicy'
type IEnforcer_SelfUpdatePolicy_Call struct {
	*mock.Call
}

// SelfUpdatePolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - oldRule []string
//   - newRule []string
func (_e *IEnforcer_Expecter) SelfUpdatePolicy(sec interface{}, ptype interface{}, oldRule interface{}, newRule interface{}) *IEnforcer_SelfUpdatePolicy_Call {
	return &IEnforcer_SelfUpdatePolicy_Call{Call: _e.mock.On("SelfUpdatePolicy", sec, ptype, oldRule, newRule)}
}

func (_c *IEnforcer_SelfUpdatePolicy_Call) Run(run func(sec string, ptype string, oldRule []string, newRule []string)) *IEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string), args[3].([]string))
	})
	return _c
}

func (_c *IEnforcer_SelfUpdatePolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_SelfUpdatePolicy_Call) RunAndReturn(run func(string, string, []string, []string) (bool, error)) *IEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SetAdapter provides a mock function with given fields: adapter
func (_m *IEnforcer) SetAdapter(adapter persist.Adapter) {
	_m.Called(adapter)
}

// IEnforcer_SetAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAdapter'
type IEnforcer_SetAdapter_Call struct {
	*mock.Call
}

// SetAdapter is a helper method to define mock.On call
//   - adapter persist.Adapter
func (_e *IEnforcer_Expecter) SetAdapter(adapter interface{}) *IEnforcer_SetAdapter_Call {
	return &IEnforcer_SetAdapter_Call{Call: _e.mock.On("SetAdapter", adapter)}
}

func (_c *IEnforcer_SetAdapter_Call) Run(run func(adapter persist.Adapter)) *IEnforcer_SetAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(persist.Adapter))
	})
	return _c
}

func (_c *IEnforcer_SetAdapter_Call) Return() *IEnforcer_SetAdapter_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_SetAdapter_Call) RunAndReturn(run func(persist.Adapter)) *IEnforcer_SetAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// SetEffector provides a mock function with given fields: eft
func (_m *IEnforcer) SetEffector(eft effector.Effector) {
	_m.Called(eft)
}

// IEnforcer_SetEffector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEffector'
type IEnforcer_SetEffector_Call struct {
	*mock.Call
}

// SetEffector is a helper method to define mock.On call
//   - eft effector.Effector
func (_e *IEnforcer_Expecter) SetEffector(eft interface{}) *IEnforcer_SetEffector_Call {
	return &IEnforcer_SetEffector_Call{Call: _e.mock.On("SetEffector", eft)}
}

func (_c *IEnforcer_SetEffector_Call) Run(run func(eft effector.Effector)) *IEnforcer_SetEffector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(effector.Effector))
	})
	return _c
}

func (_c *IEnforcer_SetEffector_Call) Return() *IEnforcer_SetEffector_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_SetEffector_Call) RunAndReturn(run func(effector.Effector)) *IEnforcer_SetEffector_Call {
	_c.Call.Return(run)
	return _c
}

// SetModel provides a mock function with given fields: m
func (_m *IEnforcer) SetModel(m model.Model) {
	_m.Called(m)
}

// IEnforcer_SetModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetModel'
type IEnforcer_SetModel_Call struct {
	*mock.Call
}

// SetModel is a helper method to define mock.On call
//   - m model.Model
func (_e *IEnforcer_Expecter) SetModel(m interface{}) *IEnforcer_SetModel_Call {
	return &IEnforcer_SetModel_Call{Call: _e.mock.On("SetModel", m)}
}

func (_c *IEnforcer_SetModel_Call) Run(run func(m model.Model)) *IEnforcer_SetModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Model))
	})
	return _c
}

func (_c *IEnforcer_SetModel_Call) Return() *IEnforcer_SetModel_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_SetModel_Call) RunAndReturn(run func(model.Model)) *IEnforcer_SetModel_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoleManager provides a mock function with given fields: rm
func (_m *IEnforcer) SetRoleManager(rm rbac.RoleManager) {
	_m.Called(rm)
}

// IEnforcer_SetRoleManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoleManager'
type IEnforcer_SetRoleManager_Call struct {
	*mock.Call
}

// SetRoleManager is a helper method to define mock.On call
//   - rm rbac.RoleManager
func (_e *IEnforcer_Expecter) SetRoleManager(rm interface{}) *IEnforcer_SetRoleManager_Call {
	return &IEnforcer_SetRoleManager_Call{Call: _e.mock.On("SetRoleManager", rm)}
}

func (_c *IEnforcer_SetRoleManager_Call) Run(run func(rm rbac.RoleManager)) *IEnforcer_SetRoleManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(rbac.RoleManager))
	})
	return _c
}

func (_c *IEnforcer_SetRoleManager_Call) Return() *IEnforcer_SetRoleManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *IEnforcer_SetRoleManager_Call) RunAndReturn(run func(rbac.RoleManager)) *IEnforcer_SetRoleManager_Call {
	_c.Call.Return(run)
	return _c
}

// SetWatcher provides a mock function with given fields: watcher
func (_m *IEnforcer) SetWatcher(watcher persist.Watcher) error {
	ret := _m.Called(watcher)

	if len(ret) == 0 {
		panic("no return value specified for SetWatcher")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(persist.Watcher) error); ok {
		r0 = rf(watcher)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IEnforcer_SetWatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWatcher'
type IEnforcer_SetWatcher_Call struct {
	*mock.Call
}

// SetWatcher is a helper method to define mock.On call
//   - watcher persist.Watcher
func (_e *IEnforcer_Expecter) SetWatcher(watcher interface{}) *IEnforcer_SetWatcher_Call {
	return &IEnforcer_SetWatcher_Call{Call: _e.mock.On("SetWatcher", watcher)}
}

func (_c *IEnforcer_SetWatcher_Call) Run(run func(watcher persist.Watcher)) *IEnforcer_SetWatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(persist.Watcher))
	})
	return _c
}

func (_c *IEnforcer_SetWatcher_Call) Return(_a0 error) *IEnforcer_SetWatcher_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IEnforcer_SetWatcher_Call) RunAndReturn(run func(persist.Watcher) error) *IEnforcer_SetWatcher_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateFilteredPolicies provides a mock function with given fields: newPolicies, fieldIndex, fieldValues
func (_m *IEnforcer) UpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, newPolicies, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFilteredPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) (bool, error)); ok {
		return rf(newPolicies, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) bool); ok {
		r0 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, int, ...string) error); ok {
		r1 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdateFilteredPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateFilteredPolicies'
type IEnforcer_UpdateFilteredPolicies_Call struct {
	*mock.Call
}

// UpdateFilteredPolicies is a helper method to define mock.On call
//   - newPolicies [][]string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *IEnforcer_Expecter) UpdateFilteredPolicies(newPolicies interface{}, fieldIndex interface{}, fieldValues ...interface{}) *IEnforcer_UpdateFilteredPolicies_Call {
	return &IEnforcer_UpdateFilteredPolicies_Call{Call: _e.mock.On("UpdateFilteredPolicies",
		append([]interface{}{newPolicies, fieldIndex}, fieldValues...)...)}
}

func (_c *IEnforcer_UpdateFilteredPolicies_Call) Run(run func(newPolicies [][]string, fieldIndex int, fieldValues ...string)) *IEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].([][]string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IEnforcer_UpdateFilteredPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdateFilteredPolicies_Call) RunAndReturn(run func([][]string, int, ...string) (bool, error)) *IEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroupingPolicies provides a mock function with given fields: oldRules, newRules
func (_m *IEnforcer) UpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdateGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroupingPolicies'
type IEnforcer_UpdateGroupingPolicies_Call struct {
	*mock.Call
}

// UpdateGroupingPolicies is a helper method to define mock.On call
//   - oldRules [][]string
//   - newRules [][]string
func (_e *IEnforcer_Expecter) UpdateGroupingPolicies(oldRules interface{}, newRules interface{}) *IEnforcer_UpdateGroupingPolicies_Call {
	return &IEnforcer_UpdateGroupingPolicies_Call{Call: _e.mock.On("UpdateGroupingPolicies", oldRules, newRules)}
}

func (_c *IEnforcer_UpdateGroupingPolicies_Call) Run(run func(oldRules [][]string, newRules [][]string)) *IEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_UpdateGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdateGroupingPolicies_Call) RunAndReturn(run func([][]string, [][]string) (bool, error)) *IEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroupingPolicy provides a mock function with given fields: oldRule, newRule
func (_m *IEnforcer) UpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdateGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroupingPolicy'
type IEnforcer_UpdateGroupingPolicy_Call struct {
	*mock.Call
}

// UpdateGroupingPolicy is a helper method to define mock.On call
//   - oldRule []string
//   - newRule []string
func (_e *IEnforcer_Expecter) UpdateGroupingPolicy(oldRule interface{}, newRule interface{}) *IEnforcer_UpdateGroupingPolicy_Call {
	return &IEnforcer_UpdateGroupingPolicy_Call{Call: _e.mock.On("UpdateGroupingPolicy", oldRule, newRule)}
}

func (_c *IEnforcer_UpdateGroupingPolicy_Call) Run(run func(oldRule []string, newRule []string)) *IEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].([]string))
	})
	return _c
}

func (_c *IEnforcer_UpdateGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdateGroupingPolicy_Call) RunAndReturn(run func([]string, []string) (bool, error)) *IEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNamedGroupingPolicies provides a mock function with given fields: ptype, oldRules, newRules
func (_m *IEnforcer) UpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) (bool, error)); ok {
		return rf(ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) bool); ok {
		r0 = rf(ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string, [][]string) error); ok {
		r1 = rf(ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdateNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNamedGroupingPolicies'
type IEnforcer_UpdateNamedGroupingPolicies_Call struct {
	*mock.Call
}

// UpdateNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - oldRules [][]string
//   - newRules [][]string
func (_e *IEnforcer_Expecter) UpdateNamedGroupingPolicies(ptype interface{}, oldRules interface{}, newRules interface{}) *IEnforcer_UpdateNamedGroupingPolicies_Call {
	return &IEnforcer_UpdateNamedGroupingPolicies_Call{Call: _e.mock.On("UpdateNamedGroupingPolicies", ptype, oldRules, newRules)}
}

func (_c *IEnforcer_UpdateNamedGroupingPolicies_Call) Run(run func(ptype string, oldRules [][]string, newRules [][]string)) *IEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string), args[2].([][]string))
	})
	return _c
}

func (_c *IEnforcer_UpdateNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdateNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string, [][]string) (bool, error)) *IEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNamedGroupingPolicy provides a mock function with given fields: ptype, oldRule, newRule
func (_m *IEnforcer) UpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []string, []string) (bool, error)); ok {
		return rf(ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, []string, []string) bool); ok {
		r0 = rf(ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, []string, []string) error); ok {
		r1 = rf(ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdateNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNamedGroupingPolicy'
type IEnforcer_UpdateNamedGroupingPolicy_Call struct {
	*mock.Call
}

// UpdateNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - oldRule []string
//   - newRule []string
func (_e *IEnforcer_Expecter) UpdateNamedGroupingPolicy(ptype interface{}, oldRule interface{}, newRule interface{}) *IEnforcer_UpdateNamedGroupingPolicy_Call {
	return &IEnforcer_UpdateNamedGroupingPolicy_Call{Call: _e.mock.On("UpdateNamedGroupingPolicy", ptype, oldRule, newRule)}
}

func (_c *IEnforcer_UpdateNamedGroupingPolicy_Call) Run(run func(ptype string, oldRule []string, newRule []string)) *IEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string), args[2].([]string))
	})
	return _c
}

func (_c *IEnforcer_UpdateNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdateNamedGroupingPolicy_Call) RunAndReturn(run func(string, []string, []string) (bool, error)) *IEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicies provides a mock function with given fields: oldPolicies, newPolicies
func (_m *IEnforcer) UpdatePolicies(oldPolicies [][]string, newPolicies [][]string) (bool, error) {
	ret := _m.Called(oldPolicies, newPolicies)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldPolicies, newPolicies)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldPolicies, newPolicies)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldPolicies, newPolicies)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdatePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicies'
type IEnforcer_UpdatePolicies_Call struct {
	*mock.Call
}

// UpdatePolicies is a helper method to define mock.On call
//   - oldPolicies [][]string
//   - newPolicies [][]string
func (_e *IEnforcer_Expecter) UpdatePolicies(oldPolicies interface{}, newPolicies interface{}) *IEnforcer_UpdatePolicies_Call {
	return &IEnforcer_UpdatePolicies_Call{Call: _e.mock.On("UpdatePolicies", oldPolicies, newPolicies)}
}

func (_c *IEnforcer_UpdatePolicies_Call) Run(run func(oldPolicies [][]string, newPolicies [][]string)) *IEnforcer_UpdatePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string), args[1].([][]string))
	})
	return _c
}

func (_c *IEnforcer_UpdatePolicies_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdatePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdatePolicies_Call) RunAndReturn(run func([][]string, [][]string) (bool, error)) *IEnforcer_UpdatePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicy provides a mock function with given fields: oldPolicy, newPolicy
func (_m *IEnforcer) UpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error) {
	ret := _m.Called(oldPolicy, newPolicy)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldPolicy, newPolicy)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldPolicy, newPolicy)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldPolicy, newPolicy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IEnforcer_UpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicy'
type IEnforcer_UpdatePolicy_Call struct {
	*mock.Call
}

// UpdatePolicy is a helper method to define mock.On call
//   - oldPolicy []string
//   - newPolicy []string
func (_e *IEnforcer_Expecter) UpdatePolicy(oldPolicy interface{}, newPolicy interface{}) *IEnforcer_UpdatePolicy_Call {
	return &IEnforcer_UpdatePolicy_Call{Call: _e.mock.On("UpdatePolicy", oldPolicy, newPolicy)}
}

func (_c *IEnforcer_UpdatePolicy_Call) Run(run func(oldPolicy []string, newPolicy []string)) *IEnforcer_UpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].([]string))
	})
	return _c
}

func (_c *IEnforcer_UpdatePolicy_Call) Return(_a0 bool, _a1 error) *IEnforcer_UpdatePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IEnforcer_UpdatePolicy_Call) RunAndReturn(run func([]string, []string) (bool, error)) *IEnforcer_UpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// NewIEnforcer creates a new instance of IEnforcer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIEnforcer(t interface {
	mock.TestingT
	Cleanup(func())
},
) *IEnforcer {
	mock := &IEnforcer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
