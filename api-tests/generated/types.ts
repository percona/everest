/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Everest API Login
         * @description This API issues a new JWT token for logging in from the Everest API.
         *     The provided user must have the `login` capability.
         */
        post: operations["createSession"];
        /**
         * Everest API Logout
         * @description This API invalidates Everest API JWT token.
         */
        delete: operations["deleteSession"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user permissions
         * @description This API returns a list of permissions for the user that is currently logged in.
         *
         *     *Example:*
         *     Assume the following RBAC policy, and users `alice` and `bob`:
         *     ```
         *     p, role:dev, namespaces, read, *
         *     p, role:dev, database-engines, *, *\/*
         *     p, role:dev, database-clusters, *, *\/*
         *     p, bob, database-clusters, *, *\/*
         *     g, alice, role:dev
         *     ```
         *     The API will return the following permissions for `alice`:
         *     ```
         *     {
         *       "permissions": [
         *         [
         *             "alice",
         *             "namespaces",
         *             "read",
         *             "*"
         *         ],
         *         [
         *             "alice",
         *             "database-engines",
         *             "*",
         *             "*\/*"
         *         ],
         *         [
         *             "alice",
         *             "database-clusters",
         *             "*",
         *             "*\/*"
         *         ]
         *       ]
         *     }
         *     ```
         *     And the following permissions for `bob`:
         *     ```
         *     {
         *       "permissions": [
         *         [
         *             "bob",
         *             "database-clusters",
         *             "*",
         *             "*\/*"
         *         ]
         *       ]
         *     }
         *     ```
         */
        get: operations["getUserPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Managed namespaces
         * @description This API returns a list of namespaces managed by Everest.
         */
        get: operations["listNamespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Version
         * @description This API returns the version of the Everest API server.
         */
        get: operations["versionInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Settings
         * @description This API returns the settings of the Everest installation.
         */
        get: operations["getSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Cluster resources
         * @description This API gets the capacity and available resources of the Kubernetes cluster.
         */
        get: operations["getKubernetesClusterResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/cluster-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Cluster info
         * @description This API gets the cluster type and the storage classes available in the cluster.
         */
        get: operations["getKubernetesClusterInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List database clusters
         * @description This API lists all database clusters in the specified namespace.
         */
        get: operations["listDatabaseClusters"];
        put?: never;
        /**
         * Create database cluster
         * @description This API creates a new database cluster in the specified namespace.
         */
        post: operations["createDatabaseCluster"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database cluster
         * @description This API gets the database cluster specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseCluster"];
        /**
         * Update database cluster
         * @description This API updates a database cluster specified by the `name` and `namespace`.
         */
        put: operations["updateDatabaseCluster"];
        post?: never;
        /**
         * Delete database cluster
         * @description This API deletes the database cluster specified by the `name` and `namespace`.
         */
        delete: operations["deleteDatabaseCluster"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{cluster-name}/backups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List database cluster backups
         * @description This API lists all database cluster backups in the specified `namespace`.
         */
        get: operations["listDatabaseClusterBackups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{cluster-name}/restores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List database cluster restores
         * @description This API lists all database cluster restores for a database cluster specified by the `name` and `namespace`.
         */
        get: operations["listDatabaseClusterRestores"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{name}/credentials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database cluster credentials
         * @description This API gets the credentials for the database cluster specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseClusterCredentials"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{name}/pitr": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Point-in-Time recovery info
         * @description This API gets the Point-in-Time recovery info for the database cluster specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseClusterPitr"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{name}/components": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database cluster components
         * @description This API gets the various components of the database cluster specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseClusterComponents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{dbName}/data-import-jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List data import jobs for a database cluster
         * @description This API lists all data import jobs for the database cluster specified by the `name` and `namespace`.
         */
        get: operations["listDataImportJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-clusters/{dbName}/secret": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a secret for the given database cluster
         * @description This API creates a secret for the database cluster specified by the `name` and `namespace`
         */
        post: operations["createDatabaseClusterSecret"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-engines": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List database engines
         * @description This API lists all database engines in the specified `namespace`.
         */
        get: operations["listDatabaseEngines"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-engines/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database engine
         * @description This API gets the database engine specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseEngine"];
        /**
         * Update database engine
         * @description This API updates the database engine specified by the `name` and `namespace`.
         */
        put: operations["updateDatabaseEngine"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-engines/upgrade-plan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get upgrade plan
         * @description This API lists pending operator upgrades in the given namespace.
         *
         *     Additionally, it also returns a list of pending action items that need to be performed
         *     before and after upgrading a database operator.
         *
         *     Added in v1.1.0, it is recommended to use this API for operator upgrades.
         *     The older upgrade APIs are deprecated and will be removed in v1.2.0
         */
        get: operations["getUpgradePlan"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-engines/upgrade-plan/approval": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upgrade database engine operators
         * @description This API upgrades all database engine operators in the specified namespace.
         *
         *     Added in v1.1.0, it is recommended to use this API for operator upgrades.
         *     The older upgrade APIs are deprecated and will be removed in v1.2.0
         */
        post: operations["approveUpgradePlan"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-cluster-restores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create database cluster restore
         * @description This API creates a new database cluster restore in the specified `namespace`.
         */
        post: operations["createDatabaseClusterRestore"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-cluster-restores/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database cluster restore
         * @description This API gets the database cluster restore specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseClusterRestore"];
        /**
         * Update database cluster restore
         * @description This API updates the database cluster restore specified by the `name` and `namespace`.
         */
        put: operations["updateDatabaseClusterRestore"];
        post?: never;
        /**
         * Delete database cluster restore
         * @description This API deletes the database cluster restore specified by the `name` and `namespace`.
         */
        delete: operations["deleteDatabaseClusterRestore"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-cluster-backups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create database cluster backup
         * @description This API creates a new database cluster backup in the specified `namespace`.
         */
        post: operations["createDatabaseClusterBackup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/database-cluster-backups/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database cluster backup
         * @description This API gets the database cluster backup specified by the `name` and `namespace`.
         */
        get: operations["getDatabaseClusterBackup"];
        put?: never;
        post?: never;
        /**
         * Delete database cluster backup
         * @description This API deletes the database cluster backup specified by the `name` and `namespace`.
         */
        delete: operations["deleteDatabaseClusterBackup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/backup-storages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List backup storages
         * @description This API lists all backup storages.
         */
        get: operations["listBackupStorages"];
        put?: never;
        /**
         * Create backup storage
         * @description This API creates a new backup storage.
         *
         *     **Examples**:
         *       ```
         *       {
         *         "metadata": {
         *           "name": "s3-storage",
         *           "namespace": "everest",
         *         },
         *         "spec": {
         *           "type": "s3",
         *           "bucketName": "bucket1",
         *           "accessKey": "access_key",
         *           "secretKey": "secret_key",
         *           "region": "eu-central-1"
         *         },
         *       }
         *       ```
         *
         *       ```
         *       {
         *         "metadata": {
         *           "name": "azure-storage",
         *           "namespace": "everest",
         *         },
         *         "spec": {
         *           "type": "azure",
         *           "bucketName": "container1",
         *           "accessKey": "storage_account_name",
         *           "secretKey": "storage_account_key",
         *         },
         *       }
         *       ```
         */
        post: operations["createBackupStorage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/backup-storages/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get backup storage
         * @description This API gets the backup storage speciciied by the `name` in the given `namespace`.
         */
        get: operations["getBackupStorage"];
        put?: never;
        post?: never;
        /**
         * Delete backup storage
         * @description This API deletes the backup storage specified by the `name`.
         */
        delete: operations["deleteBackupStorage"];
        options?: never;
        head?: never;
        /**
         * Update backup storage
         * @description This API updates the backup storage specified by the `name`. Only the specified fields will be updated.
         */
        patch: operations["updateBackupStorage"];
        trace?: never;
    };
    "/namespaces/{namespace}/monitoring-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List monitoring instances
         * @description This API lists all monitoring instances in a given namespace.
         */
        get: operations["listMonitoringInstances"];
        put?: never;
        /**
         * Create monitoring instance
         * @description This API creates a new monitoring instance.
         *
         *     A monitoring instance object requires `type` to be set.
         *     Based on the `type` the respective key with configuration needs to be set.
         *     Such as, if `type: pmm`, then `pmm` key needs to be provided with a configuration.
         */
        post: operations["createMonitoringInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/monitoring-instances/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get monitoring instance
         * @description This API gets the monitoring instance specified by the `name`.
         */
        get: operations["getMonitoringInstance"];
        put?: never;
        post?: never;
        /**
         * Delete monitoring instnace
         * @description This API deletes the monitoring instance specified by the `name`.
         */
        delete: operations["deleteMonitoringInstance"];
        options?: never;
        head?: never;
        /**
         * Update monitoring instance
         * @description This API updates the monitoring instance specified by the `name`.
         */
        patch: operations["updateMonitoringInstance"];
        trace?: never;
    };
    "/pod-scheduling-policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List pod scheduling policies
         * @description This API lists all pod scheduling policies in the kubernetes cluster.
         */
        get: operations["listPodSchedulingPolicy"];
        put?: never;
        /**
         * Create pod scheduling policy
         * @description This API creates a new pod scheduling policy.
         */
        post: operations["createPodSchedulingPolicy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pod-scheduling-policies/{policy-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get pod scheduling policy
         * @description This API gets the pod scheduling policy specified by the `name`.
         */
        get: operations["getPodSchedulingPolicy"];
        /**
         * Update pod scheduling policy
         * @description This API updates a pod scheduling policy specified by the `name`.
         */
        put: operations["updatePodSchedulingPolicy"];
        post?: never;
        /**
         * Delete pod scheduling policy
         * @description This API deletes the pod scheduling policy specified by the `name`.
         */
        delete: operations["deletePodSchedulingPolicy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data-importers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List data importers
         * @description This API lists all data importers in the kubernetes cluster.
         */
        get: operations["listDataImporters"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/load-balancer-configs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List load balancer configs
         * @description This API lists all load balancer configs in the kubernetes cluster.
         */
        get: operations["listLoadBalancerConfig"];
        put?: never;
        /**
         * Create load balancer config
         * @description This API creates a new load balancer config.
         */
        post: operations["createLoadBalancerConfig"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/load-balancer-configs/{config-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get load balancer config
         * @description This API gets the load balancer config specified by the `name`.
         */
        get: operations["getLoadBalancerConfig"];
        /**
         * Update load balancer config
         * @description This API updates a load balancer config specified by the `name`.
         */
        put: operations["updateLoadBalancerConfig"];
        post?: never;
        /**
         * Delete load balancer config
         * @description This API deletes the load balancer config specified by the `name`.
         */
        delete: operations["deleteLoadBalancerConfig"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/engine-features/split-horizon-dns-configs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Split-Horizon DNS Config instances.
         * @description This API lists all Split-Horizon DNS Config instances in a given namespace.
         */
        get: operations["listSplitHorizonDNSConfigs"];
        put?: never;
        /**
         * Create Split-Horizon DNS Config for PSMDB.
         * @description This API creates a new Split-Horizon DNS Config instance.
         */
        post: operations["createSplitHorizonDNSConfig"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{namespace}/engine-features/split-horizon-dns-configs/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Split-Horizon DNS Config instance.
         * @description This API gets the Split-Horizon DNS Config instance specified by the `name`.
         */
        get: operations["getSplitHorizonDNSConfig"];
        put?: never;
        post?: never;
        /**
         * Delete Split-Horizon DNS Config instance.
         * @description This API deletes the Split-Horizon DNS Config instance specified by the `name`.
         */
        delete: operations["deleteSplitHorizonDNSConfig"];
        options?: never;
        head?: never;
        /**
         * Update Split-Horizon DNS Config instance.
         * @description This API updates the Split-Horizon DNS Config instance specified by the `name`.
         */
        patch: operations["updateSplitHorizonDNSConfig"];
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description Error response */
        Error: {
            message?: string;
        };
        NamespaceList: string[];
        UserPermissions: {
            enabled: boolean;
            permissions?: string[][];
        };
        UserCredentials: {
            username?: string;
            password?: string;
        };
        /** @description Backup storage parameters */
        CreateBackupStorageParams: {
            /**
             * @description A user defined string name of the storage in the DNS name format https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names
             * @example aws-dev
             */
            name: string;
            description?: string;
            /** @enum {string} */
            type: "s3" | "azure";
            /** @description The cloud storage bucket/container name */
            bucketName: string;
            accessKey: string;
            secretKey: string;
            url?: string;
            region?: string;
            /**
             * @deprecated
             * @description List of namespaces allowed to use this backup storage
             */
            allowedNamespaces?: string[];
            /** @default true */
            verifyTLS: boolean;
            /** @default false */
            forcePathStyle: boolean;
        };
        /** @description Backup storage parameters */
        UpdateBackupStorageParams: {
            description?: string;
            /** @description The cloud storage bucket/container name */
            bucketName?: string;
            accessKey?: string;
            secretKey?: string;
            url?: string;
            region?: string;
            verifyTLS?: boolean;
            forcePathStyle?: boolean;
            /**
             * @deprecated
             * @description List of namespaces allowed to use this backup storage
             */
            allowedNamespaces?: string[];
        };
        /** @description Operator version checks for a single database */
        OperatorVersionCheckForDatabase: {
            /** @description Name of the database cluster */
            name?: string;
            message?: string;
            /**
             * @description Pending task for the database cluster
             * @enum {string}
             */
            pendingTask?: "restart";
        };
        /** @description Operator version check results */
        OperatorVersion: {
            /** @description The current operator version */
            currentVersion?: string;
            databases?: components["schemas"]["OperatorVersionCheckForDatabase"][];
        };
        /**
         * @deprecated
         * @description Operator upgrade preflight check results for a database
         */
        OperatorUpgradePreflightForDatabase: {
            /** @description Name of the database cluster */
            name?: string;
            message?: string;
            /**
             * @description Pending task for the database cluster
             * @enum {string}
             */
            pendingTask?: "ready" | "notReady" | "restart" | "upgradeEngine";
        };
        UpgradeTask: {
            /** @description Name of the database cluster */
            name?: string;
            message?: string;
            /**
             * @description Pending task for the database cluster
             * @enum {string}
             */
            pendingTask?: "ready" | "notReady" | "restart" | "upgradeEngine";
        };
        Upgrade: {
            /** @description Name of the operator */
            name?: string;
            /** @description The current operator version */
            currentVersion?: string;
            /** @description The next version of the operator to upgrade to. */
            targetVersion?: string;
        };
        /** @description Operators upgrade plan */
        UpgradePlan: {
            upgrades?: components["schemas"]["Upgrade"][];
            pendingActions?: components["schemas"]["UpgradeTask"][];
        };
        /**
         * @deprecated
         * @description Operator upgrade preflight check results
         */
        OperatorUpgradePreflight: {
            /** @description The current operator version */
            currentVersion?: string;
            databases?: components["schemas"]["OperatorUpgradePreflightForDatabase"][];
        };
        /** @description Backup storage information */
        BackupStorage: {
            /** @enum {string} */
            type: "s3" | "azure";
            namespace?: string;
            name: string;
            description?: string;
            bucketName: string;
            url?: string;
            region?: string;
            /** @default true */
            verifyTLS: boolean;
            /** @default false */
            forcePathStyle: boolean;
            /**
             * @deprecated
             * @description List of namespaces allowed to use this backup storage
             */
            allowedNamespaces?: string[];
        };
        BackupStoragesList: components["schemas"]["BackupStorage"][];
        /** @description Monitoring instance information */
        MonitoringInstanceBase: {
            /** @enum {string} */
            type?: "pmm";
            url?: string;
            /**
             * @deprecated
             * @description List of namespaces allowed to use this monitoring instance
             */
            allowedNamespaces?: string[];
            /** @description VerifyTLS is set to ensure TLS/SSL verification. */
            verifyTLS?: boolean;
        };
        /** @description Monitoring instance information */
        MonitoringInstanceBaseWithName: components["schemas"]["MonitoringInstanceBase"] & {
            /**
             * @description A user defined string name of the storage in the DNS name format https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names
             * @example pmm-instance
             */
            name?: string;
            namespace?: string;
        };
        MonitoringInstancePMM: {
            pmm?: {
                /** @example admin */
                user?: string;
                /** @example password */
                password?: string;
                /** @example apikey */
                apiKey?: string;
            };
        };
        /** @description Monitoring instance create information */
        MonitoringInstanceCreateParams: components["schemas"]["MonitoringInstanceBaseWithName"] & components["schemas"]["MonitoringInstancePMM"];
        /** @description Monitoring instance update information */
        MonitoringInstanceUpdateParams: components["schemas"]["MonitoringInstanceBase"] & components["schemas"]["MonitoringInstancePMM"];
        /** @description Monitoring instance information */
        MonitoringInstance: components["schemas"]["MonitoringInstanceBaseWithName"];
        MonitoringInstancesList: components["schemas"]["MonitoringInstance"][];
        /** @description kubernetes object */
        DatabaseClusterCredential: {
            /** @example postgres://user:secret@100.100.100.100:5432 */
            connectionUrl?: string;
            /** @example root */
            username?: string;
            /** @example root */
            password?: string;
        };
        /** @description components related data */
        DatabaseClusterComponents: {
            status?: string;
            name?: string;
            type?: string;
            started?: string;
            restarts?: number;
            ready?: string;
            containers?: components["schemas"]["DatabaseClusterComponentContainer"][];
        }[];
        DatabaseClusterComponentContainer: {
            name?: string;
            started?: string;
            ready?: boolean;
            restarts?: number;
            status?: string;
        };
        /** @description point-in-time recovery related data */
        DatabaseClusterPitr: {
            /**
             * Format: date-time
             * @example 2023-12-31T23:59:59Z
             */
            earliestDate?: string;
            /**
             * Format: date-time
             * @example 2023-12-31T23:59:59Z
             */
            latestDate?: string;
            latestBackupName?: string;
            /** @description indicates if there are pitr logs gaps detected after this backup was taken */
            gaps?: boolean;
        };
        /** @description kubernetes cluster resources */
        KubernetesClusterResources: {
            capacity: {
                cpuMillis?: number;
                memoryBytes?: number;
                diskSize?: number;
            };
            available: {
                cpuMillis?: number;
                memoryBytes?: number;
                diskSize?: number;
            };
        };
        /** @description kubernetes cluster info */
        KubernetesClusterInfo: {
            clusterType: string;
            /**
             * @deprecated
             * @description List of storage class names that are available in the cluster.
             * @example [
             *       "gp2",
             *       "gp3"
             *     ]
             */
            storageClassNames: string[];
            storageClasses?: components["schemas"]["StorageClass"][];
        };
        /** @description Everest version info */
        Version: {
            projectName: string;
            version: string;
            fullCommit: string;
        };
        /** @description Everest global settings */
        Settings: {
            oidcConfig: components["schemas"]["OIDCConfig"];
        };
        /** @description Everest OIDC provider configuration */
        OIDCConfig: {
            /** @description OIDC application clientID */
            clientId: string;
            /** @description OIDC provider url */
            issuerURL: string;
            /** @description OIDC scopes */
            scopes: string[];
        };
        /** @description DatabaseClusterList is an object that contains the list of the existing database clusters. */
        DatabaseClusterList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DatabaseCluster"][];
            metadata?: Record<string, never>;
        };
        /** @description DatabaseEngineList is an object that contains the list of the existing database engines. */
        DatabaseEngineList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DatabaseEngine"][];
            metadata?: Record<string, never>;
        };
        /** @description This no-op object is used to trigger the operator upgrade in a namespace. */
        UpgradePlanApproval: Record<string, never>;
        /**
         * @deprecated
         * @description Database engine operator upgrade parameters
         */
        DatabaseEngineOperatorUpgradeParams: {
            /**
             * @description The version to which the operator should be upgraded
             * @example 0.12.0
             */
            targetVersion: string;
        };
        /** @description DatabaseClusterRestoreList is an object that contains the list of the existing database cluster restores. */
        DatabaseClusterRestoreList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DatabaseClusterRestore"][];
            metadata?: Record<string, never>;
        };
        /** @description DatabaseClusterBackupList is an object that contains the list of the existing database cluster backups. */
        DatabaseClusterBackupList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DatabaseClusterBackup"][];
            metadata?: Record<string, never>;
        };
        /** @description PodSchedulingPolicyList is an object that contains the list of the existing pod scheduling policies. */
        PodSchedulingPolicyList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["PodSchedulingPolicy"][];
            metadata?: Record<string, never>;
        };
        /** @description LoadBalancerConfigList is an object that contains the list of the existing load balancer configs. */
        LoadBalancerConfigList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["LoadBalancerConfig"][];
            metadata?: Record<string, never>;
        };
        /** @description SplitHorizonDNSConfigList is an object that contains the list of the existing split-horizon dns configs. */
        SplitHorizonDNSConfigList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["SplitHorizonDNSConfig"][];
            metadata?: Record<string, never>;
        };
        /** @description sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir */
        SizeLimit: components["schemas"]["Integer"] | components["schemas"]["String"];
        Integer: number;
        String: string;
        /** @description DatabaseEngine is the Schema for the databaseengines API. */
        DatabaseEngine: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description DatabaseEngineSpec is a spec for a database engine. */
            spec?: {
                allowedVersions?: string[];
                /**
                 * @description SecretKeys contains the definition of the various Secrets that
                 *     the given DBEngine supports.
                 *     This information acts like metadata for the Everest UI to guide the users
                 *     in filling out the correct Secret keys for their clusters.
                 */
                secretKeys?: {
                    /** @description User secret keys are used to store the details of the users. */
                    user?: {
                        /** @description Description is a human-readable description of the Secret key. */
                        description?: string;
                        /** @description Name is the name of the Secret key. */
                        name?: string;
                    }[];
                };
                /**
                 * @description EngineType stands for the supported database engines. Right now it's only pxc
                 *     and psmdb. However, it can be ps, pg and any other source.
                 */
                type: string;
            };
            /** @description DatabaseEngineStatus defines the observed state of DatabaseEngine. */
            status?: {
                /** @description Versions struct represents available versions of database engine components. */
                availableVersions?: {
                    /** @description ComponentsMap is a map of database engine components. */
                    backup?: {
                        [key: string]: {
                            critical?: boolean;
                            imageHash?: string;
                            imagePath?: string;
                            /** @description ComponentStatus represents status of the database engine component. */
                            status?: string;
                        };
                    };
                    /** @description ComponentsMap is a map of database engine components. */
                    engine?: {
                        [key: string]: {
                            critical?: boolean;
                            imageHash?: string;
                            imagePath?: string;
                            /** @description ComponentStatus represents status of the database engine component. */
                            status?: string;
                        };
                    };
                    proxy?: {
                        [key: string]: {
                            [key: string]: {
                                critical?: boolean;
                                imageHash?: string;
                                imagePath?: string;
                                /** @description ComponentStatus represents status of the database engine component. */
                                status?: string;
                            };
                        };
                    };
                    tools?: {
                        [key: string]: {
                            [key: string]: {
                                critical?: boolean;
                                imageHash?: string;
                                imagePath?: string;
                                /** @description ComponentStatus represents status of the database engine component. */
                                status?: string;
                            };
                        };
                    };
                };
                /** @description OperatorUpgrade contains the status of the operator upgrade. */
                operatorUpgrade?: {
                    /**
                     * @description InstallPlanRef is a reference to the InstallPlan object created for the operator upgrade.
                     *
                     *     We do not recommended approving this InstallPlan directly from the Kubernetes API.
                     *     This is because this InstallPlan may also upgrade other operators in the namespace and that
                     *     can have unintended consequences.
                     *     This behaviour is not a bug from Everest, but an unfortunate limitation of OLM.
                     *     We suggest using the Everest API/UI to handle operator upgrades, which will perform a series
                     *     of checks and safely upgrade all operators in the namespace.
                     */
                    installPlanRef?: {
                        /**
                         * @description Name of the referent.
                         *     This field is effectively required, but due to backwards compatibility is
                         *     allowed to be empty. Instances of this type with an empty value here are
                         *     almost certainly wrong.
                         *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                         * @default
                         */
                        name: string;
                    };
                    message?: string;
                    /** @description UpgradePhase represents the phase of the operator upgrade. */
                    phase?: string;
                    /** Format: date-time */
                    startedAt?: string;
                    /** @description TargetVersion is the version to which the operator should be upgraded. */
                    targetVersion?: string;
                };
                operatorVersion?: string;
                pendingOperatorUpgrades?: {
                    /**
                     * @description InstallPlanRef is a reference to the InstallPlan object created for the operator upgrade.
                     *
                     *     We do not recommended approving this InstallPlan directly from the Kubernetes API.
                     *     This is because this InstallPlan may also upgrade other operators in the namespace and that
                     *     can have unintended consequences.
                     *     This behaviour is not a bug from Everest, but an unfortunate limitation of OLM.
                     *     We suggest using the Everest API/UI to handle operator upgrades, which will perform a series
                     *     of checks and safely upgrade all operators in the namespace.
                     */
                    installPlanRef?: {
                        /**
                         * @description Name of the referent.
                         *     This field is effectively required, but due to backwards compatibility is
                         *     allowed to be empty. Instances of this type with an empty value here are
                         *     almost certainly wrong.
                         *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                         * @default
                         */
                        name: string;
                    };
                    /** @description TargetVersion is the version to which the operator should be upgraded. */
                    targetVersion?: string;
                }[];
                /** @description EngineState represents state of engine in a k8s cluster. */
                status?: string;
            };
        };
        /** @description DatabaseCluster is the Schema for the databaseclusters API. */
        DatabaseCluster: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description DatabaseClusterSpec defines the desired state of DatabaseCluster. */
            spec?: {
                /**
                 * @description AllowUnsafeConfiguration field used to ensure that the user can create configurations unfit for production use.
                 *
                 *     Deprecated: AllowUnsafeConfiguration will not be supported in the future releases.
                 */
                allowUnsafeConfiguration?: boolean;
                /** @description Backup is the backup specification */
                backup?: {
                    /**
                     * @description Enabled is a flag to enable backups
                     *     Deprecated. Please use db.spec.backup.schedules[].enabled to control each schedule separately and db.spec.backup.pitr.enabled to control PITR.
                     */
                    enabled?: boolean;
                    /** @description PITR is the configuration of the point in time recovery */
                    pitr?: {
                        /**
                         * @description BackupStorageName is the name of the BackupStorage where the PITR is enabled
                         *     The BackupStorage must be created in the same namespace as the DatabaseCluster.
                         */
                        backupStorageName?: string;
                        /** @description Enabled is a flag to enable PITR */
                        enabled: boolean;
                        /** @description UploadIntervalSec number of seconds between the binlogs uploads */
                        uploadIntervalSec?: number;
                    };
                    /** @description Schedules is a list of backup schedules */
                    schedules?: {
                        /**
                         * @description BackupStorageName is the name of the BackupStorage CR that defines the
                         *     storage location.
                         *     The BackupStorage must be created in the same namespace as the DatabaseCluster.
                         */
                        backupStorageName: string;
                        /** @description Enabled is a flag to enable the schedule */
                        enabled: boolean;
                        /** @description Name is the name of the schedule */
                        name: string;
                        /**
                         * Format: int32
                         * @description RetentionCopies is the number of backup copies to retain
                         */
                        retentionCopies?: number;
                        /** @description Schedule is the cron schedule */
                        schedule: string;
                    }[];
                };
                /** @description DataSource defines a data source for bootstraping a new cluster */
                dataSource?: {
                    /** @description BackupSource is the backup source to restore from */
                    backupSource?: {
                        /**
                         * @description BackupStorageName is the name of the BackupStorage used for storing backups.
                         *     The BackupStorage must be created in the same namespace as the DatabaseCluster.
                         */
                        backupStorageName: string;
                        /** @description Path is the path to the backup file/directory. */
                        path: string;
                    };
                    /** @description DataImport allows importing data from an external backup source. */
                    dataImport?: {
                        /**
                         * @description Config defines the configuration for the data import job.
                         *     These options are specific to the DataImporter being used and must conform to
                         *     the schema defined in the DataImporter's .spec.config.openAPIV3Schema.
                         */
                        config?: Record<string, never>;
                        /** @description DataImporterName is the data importer to use for the import. */
                        dataImporterName: string;
                        /** @description Source is the source of the data to import. */
                        source: {
                            /**
                             * @description Path is the path to the directory to import the data from.
                             *     This may be a path to a file or a directory, depending on the data importer.
                             *     Only absolute file paths are allowed. Leading and trailing '/' are optional.
                             */
                            path: string;
                            /** @description S3 contains the S3 information for the data import. */
                            s3?: {
                                /**
                                 * @description AccessKeyID allows specifying the S3 access key ID inline.
                                 *     It is provided as a write-only input field for convenience.
                                 *     When this field is set, a webhook writes this value in the Secret specified by `credentialsSecretName`
                                 *     and empties this field.
                                 *     This field is not stored in the API.
                                 */
                                accessKeyId?: string;
                                /** @description Bucket is the name of the S3 bucket. */
                                bucket: string;
                                /**
                                 * @description CredentialsSecreName is the reference to the secret containing the S3 credentials.
                                 *     The Secret must contain the keys `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
                                 */
                                credentialsSecretName: string;
                                /** @description EndpointURL is an endpoint URL of backup storage. */
                                endpointURL: string;
                                /**
                                 * @description ForcePathStyle is set to use path-style URLs.
                                 *     If unspecified, the default value is false.
                                 * @default false
                                 */
                                forcePathStyle: boolean;
                                /** @description Region is the region of the S3 bucket. */
                                region: string;
                                /**
                                 * @description SecretAccessKey allows specifying the S3 secret access key inline.
                                 *     It is provided as a write-only input field for convenience.
                                 *     When this field is set, a webhook writes this value in the Secret specified by `credentialsSecretName`
                                 *     and empties this field.
                                 *     This field is not stored in the API.
                                 */
                                secretAccessKey?: string;
                                /**
                                 * @description VerifyTLS is set to ensure TLS/SSL verification.
                                 *     If unspecified, the default value is true.
                                 * @default true
                                 */
                                verifyTLS: boolean;
                            };
                        };
                    };
                    /** @description DBClusterBackupName is the name of the DB cluster backup to restore from */
                    dbClusterBackupName?: string;
                    /** @description PITR is the point-in-time recovery configuration */
                    pitr?: {
                        /** @description Date is the UTC date to recover to. The accepted format: "2006-01-02T15:04:05Z". */
                        date?: string;
                        /**
                         * @description Type is the type of recovery.
                         * @default date
                         * @enum {string}
                         */
                        type: "date" | "latest";
                    };
                };
                /** @description Engine is the database engine specification */
                engine: {
                    /** @description Config is the engine configuration */
                    config?: string;
                    /**
                     * @description CRVersion is the desired version of the CR to use with the
                     *     underlying operator.
                     *     If unspecified, everest-operator will use the same version as the operator.
                     *
                     *     NOTE: Updating this property post installation may lead to a restart of the cluster.
                     */
                    crVersion?: string;
                    /**
                     * Format: int32
                     * @description Replicas is the number of engine replicas
                     */
                    replicas?: number;
                    /**
                     * @description Resources are the resource limits for each engine replica.
                     *     If not set, resource limits are not imposed
                     */
                    resources?: {
                        /** @description CPU is the CPU resource requirements */
                        cpu?: number | string;
                        /** @description Memory is the memory resource requirements */
                        memory?: number | string;
                    };
                    /** @description Storage is the engine storage configuration */
                    storage: {
                        /** @description Class is the storage class to use for the persistent volume claim */
                        class?: string;
                        /** @description Size is the size of the persistent volume claim */
                        size: number | string;
                    };
                    /**
                     * @description Type is the engine type
                     * @enum {string}
                     */
                    type: "pxc" | "postgresql" | "psmdb";
                    /** @description UserSecretsName is the name of the secret containing the user secrets */
                    userSecretsName?: string;
                    /** @description Version is the engine version */
                    version?: string;
                };
                /** @description EngineFeatures represents configuration of additional features for the database engine. */
                engineFeatures?: {
                    /** @description PSMDB represents additional features for the PSMDB engine. */
                    psmdb?: {
                        /**
                         * @description SplitHorizonDNSConfigName is the name of a SplitHorizonDNSConfig CR.
                         *     The SplitHorizonDNSConfig must be created in the same namespace as the DatabaseCluster.
                         */
                        splitHorizonDnsConfigName?: string;
                    };
                };
                /** @description Monitoring is the monitoring configuration */
                monitoring?: {
                    /**
                     * @description MonitoringConfigName is the name of a monitoringConfig CR.
                     *     The MonitoringConfig must be created in the same namespace as the DatabaseCluster.
                     */
                    monitoringConfigName?: string;
                    /** @description Resources defines resource limitations for the monitoring. */
                    resources?: {
                        /**
                         * @description Claims lists the names of resources, defined in spec.resourceClaims,
                         *     that are used by this container.
                         *
                         *     This field depends on the
                         *     DynamicResourceAllocation feature gate.
                         *
                         *     This field is immutable. It can only be set for containers.
                         */
                        claims?: {
                            /**
                             * @description Name must match the name of one entry in pod.spec.resourceClaims of
                             *     the Pod where this field is used. It makes that resource available
                             *     inside a container.
                             */
                            name: string;
                            /**
                             * @description Request is the name chosen for a request in the referenced claim.
                             *     If empty, everything from the claim is made available, otherwise
                             *     only the result of this request.
                             */
                            request?: string;
                        }[];
                        /**
                         * @description Limits describes the maximum amount of compute resources allowed.
                         *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
                         */
                        limits?: {
                            [key: string]: number | string;
                        };
                        /**
                         * @description Requests describes the minimum amount of compute resources required.
                         *     If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
                         *     otherwise to an implementation-defined value. Requests cannot exceed Limits.
                         *     More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
                         */
                        requests?: {
                            [key: string]: number | string;
                        };
                    };
                };
                /** @description Paused is a flag to stop the cluster */
                paused?: boolean;
                /** @description PodSchedulingPolicyName is the name of the PodSchedulingPolicy CR that defines rules for DB cluster pods allocation across the cluster. */
                podSchedulingPolicyName?: string;
                /**
                 * @description Proxy is the proxy specification. If not set, an appropriate
                 *     proxy specification will be applied for the given engine. A
                 *     common use case for setting this field is to control the
                 *     external access to the database cluster.
                 */
                proxy?: {
                    /** @description Config is the proxy configuration */
                    config?: string;
                    /** @description Expose is the proxy expose configuration */
                    expose?: {
                        /**
                         * @description IPSourceRanges is the list of IP source ranges (CIDR notation)
                         *     to allow access from. If not set, there is no limitations
                         */
                        ipSourceRanges?: string[];
                        /** @description LoadBalancerConfigName is the name of load balancer config if applied */
                        loadBalancerConfigName?: string;
                        /**
                         * @description Type is the expose type, can be internal or external
                         * @default internal
                         * @enum {string}
                         */
                        type: "internal" | "external";
                    };
                    /**
                     * Format: int32
                     * @description Replicas is the number of proxy replicas
                     */
                    replicas?: number;
                    /**
                     * @description Resources are the resource limits for each proxy replica.
                     *     If not set, resource limits are not imposed
                     */
                    resources?: {
                        /** @description CPU is the CPU resource requirements */
                        cpu?: number | string;
                        /** @description Memory is the memory resource requirements */
                        memory?: number | string;
                    };
                    /**
                     * @description Type is the proxy type
                     * @enum {string}
                     */
                    type?: "mongos" | "haproxy" | "proxysql" | "pgbouncer";
                };
                /** @description Sharding is the sharding configuration. PSMDB-only */
                sharding?: {
                    /** @description ConfigServer represents the sharding configuration server settings */
                    configServer: {
                        /**
                         * Format: int32
                         * @description Replicas is the amount of configServers
                         */
                        replicas: number;
                    };
                    /** @description Enabled defines if the sharding is enabled */
                    enabled: boolean;
                    /**
                     * Format: int32
                     * @description Shards defines the number of shards
                     */
                    shards: number;
                };
            };
            /** @description DatabaseClusterStatus defines the observed state of DatabaseCluster. */
            status?: {
                /** @description ActiveStorage is the storage used in cluster (psmdb only) */
                activeStorage?: string;
                /** @description Conditions contains the observed conditions of the DatabaseCluster. */
                conditions?: {
                    /**
                     * Format: date-time
                     * @description lastTransitionTime is the last time the condition transitioned from one status to another.
                     *     This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                     */
                    lastTransitionTime: string;
                    /**
                     * @description message is a human readable message indicating details about the transition.
                     *     This may be an empty string.
                     */
                    message: string;
                    /**
                     * Format: int64
                     * @description observedGeneration represents the .metadata.generation that the condition was set based upon.
                     *     For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                     *     with respect to the current state of the instance.
                     */
                    observedGeneration?: number;
                    /**
                     * @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                     *     Producers of specific condition types may define expected values and meanings for this field,
                     *     and whether the values are considered a guaranteed API.
                     *     The value should be a CamelCase string.
                     *     This field may not be empty.
                     */
                    reason: string;
                    /**
                     * @description status of the condition, one of True, False, Unknown.
                     * @enum {string}
                     */
                    status: "True" | "False" | "Unknown";
                    /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                    type: string;
                }[];
                /** @description CRVersion is the observed version of the CR used with the underlying operator. */
                crVersion?: string;
                /**
                 * @description DataImportJobName refers to the DataImportJob that is used to import data into the cluster.
                 *     This is set only when .spec.dataSource.dataImport is set.
                 */
                dataImportJobName?: string;
                /** @description Details provides full status of the upstream cluster as a plain text. */
                details?: string;
                /** @description EngineFeaturesStatus represents additional features statuses for the database engine. */
                engineFeatures?: {
                    /** @description PSMDB represents additional features statuses for the PSMDB engine. */
                    psmdb?: {
                        /** @description SplitHorizon status of SplitHorizon feature. */
                        splitHorizon?: {
                            /** @description SplitHorizon status of SplitHorizon feature. */
                            domains?: {
                                /** @description Domain is the SplitHorizon domain name. */
                                domain?: string;
                                /** @description PrivateIP is the private IP address for the domain. */
                                privateIP?: string;
                                /** @description PublicIP is the public IP address for the domain. */
                                publicIP?: string;
                            }[];
                            /** @description ConnectionURL is the connection URL using SplitHorizon domains. */
                            host?: string;
                        };
                    };
                };
                /** @description Hostname is the hostname where the cluster can be reached */
                hostname?: string;
                /** @description Message is extra information about the cluster */
                message?: string;
                /**
                 * Format: int64
                 * @description ObservedGeneration is the most recent generation observed for this DatabaseCluster.
                 */
                observedGeneration?: number;
                /**
                 * Format: int32
                 * @description Port is the port where the cluster can be reached
                 */
                port?: number;
                /**
                 * Format: int32
                 * @description Ready is the number of ready pods
                 */
                ready?: number;
                /**
                 * @description RecommendedCRVersion indicates the target version that the underlying CR should be updated to.
                 *     When this field is set, it means the CR is running an outdated version and requires an update.
                 *     The following restrictions apply until the CR is updated to the recommended version:
                 *     - The operator cannot be upgraded
                 *     - The database engine version (.spec.engine.version) cannot be modified
                 *     This field is unset when the CR is already running at the latest recommended version.
                 */
                recommendedCRVersion?: string;
                /**
                 * Format: int32
                 * @description Size is the total number of pods
                 */
                size?: number;
                /** @description Status is the status of the cluster */
                status?: string;
            };
        };
        /** @description DatabaseClusterBackup is the Schema for the databaseclusterbackups API. */
        DatabaseClusterBackup: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description DatabaseClusterBackupSpec defines the desired state of DatabaseClusterBackup. */
            spec?: {
                /**
                 * @description BackupStorageName is the name of the BackupStorage used for backups.
                 *     The BackupStorage must be created in the same namespace as the DatabaseCluster.
                 */
                backupStorageName: string;
                /** @description DBClusterName is the original database cluster name. */
                dbClusterName: string;
            };
            /** @description DatabaseClusterBackupStatus defines the observed state of DatabaseClusterBackup. */
            status?: {
                /**
                 * Format: date-time
                 * @description Completed is the time when the job was completed.
                 */
                completed?: string;
                /**
                 * Format: date-time
                 * @description Created is the timestamp of the upstream backup's creation.
                 */
                created?: string;
                /** @description Destination is the full path to the backup. */
                destination?: string;
                /** @description Gaps identifies if there are gaps detected in the PITR logs */
                gaps: boolean;
                /**
                 * @description InUse is a flag that indicates if this restore resource is being used to restore DB cluster from backup.
                 * @default false
                 */
                inUse: boolean;
                /**
                 * Format: date-time
                 * @description LatestRestorableTime is the latest time that can be used for PITR restore
                 */
                latestRestorableTime?: string;
                /** @description State is the DatabaseBackup state. */
                state?: string;
            };
        };
        /** @description DatabaseClusterRestore is the Schema for the databaseclusterrestores API. */
        DatabaseClusterRestore: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description DatabaseClusterRestoreSpec defines the desired state of DatabaseClusterRestore. */
            spec?: {
                /** @description DataSource defines a data source for restoration. */
                dataSource: {
                    /**
                     * @description BackupSource is the backup source to restore from.
                     *     Shall be set either this field or DBClusterBackupName.
                     */
                    backupSource?: {
                        /**
                         * @description BackupStorageName is the name of the BackupStorage used for storing backups.
                         *     The BackupStorage must be created in the same namespace as the DatabaseCluster.
                         */
                        backupStorageName: string;
                        /** @description Path is the path to the backup file/directory. */
                        path: string;
                    };
                    /**
                     * @description DBClusterBackupName is the name of the DB cluster backup to restore from.
                     *     Shall be set either this field or BackupSource.
                     */
                    dbClusterBackupName?: string;
                    /**
                     * @description PITR is the point-in-time recovery configuration.
                     *     May be set in addition to DBClusterBackupName or BackupSource to perform PITR restore.
                     */
                    pitr?: {
                        /** @description Date is the UTC date to recover to. The accepted format: "2006-01-02T15:04:05Z". */
                        date?: string;
                        /**
                         * @description Type is the type of recovery.
                         * @default date
                         * @enum {string}
                         */
                        type: "date" | "latest";
                    };
                };
                /** @description DBClusterName defines the target database cluster name that needs to be restored from backup. */
                dbClusterName: string;
            };
            /** @description DatabaseClusterRestoreStatus defines the observed state of DatabaseClusterRestore. */
            status?: {
                /** Format: date-time */
                completed?: string;
                /**
                 * @description InUse is a flag that indicates if this restore resource is being used to restore DB cluster from backup.
                 * @default false
                 */
                inUse: boolean;
                message?: string;
                /** @description RestoreState represents state of restoration. */
                state?: string;
            };
        };
        /** @description DataImportJob is the schema for the dataimportjobs API. */
        DataImportJob: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            spec?: {
                /**
                 * @description Config defines the configuration for the data import job.
                 *     These options are specific to the DataImporter being used and must conform to
                 *     the schema defined in the DataImporter's .spec.config.openAPIV3Schema.
                 */
                config?: Record<string, never>;
                /** @description DataImporterName is the data importer to use for the import. */
                dataImporterName: string;
                /** @description Source is the source of the data to import. */
                source: {
                    /**
                     * @description Path is the path to the directory to import the data from.
                     *     This may be a path to a file or a directory, depending on the data importer.
                     */
                    path?: string;
                    /** @description S3 contains the S3 information for the data import. */
                    s3?: {
                        /**
                         * @description AccessKeyID allows specifying the S3 access key ID inline.
                         *     It is provided as a write-only input field for convenience.
                         *     When this field is set, a webhook writes this value in the Secret specified by `credentialsSecretName`
                         *     and empties this field.
                         *     This field is not stored in the API.
                         */
                        accessKeyId?: string;
                        /** @description Bucket is the name of the S3 bucket. */
                        bucket?: string;
                        /**
                         * @description CredentialsSecreName is the reference to the secret containing the S3 credentials.
                         *     The Secret must contain the keys `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
                         */
                        credentialsSecretName: string;
                        /** @description EndpointURL is an endpoint URL of backup storage. */
                        endpointURL?: string;
                        /**
                         * @description ForcePathStyle is set to use path-style URLs.
                         *     If unspecified, the default value is false.
                         * @default false
                         */
                        forcePathStyle: boolean;
                        /** @description Region is the region of the S3 bucket. */
                        region?: string;
                        /**
                         * @description SecretAccessKey allows specifying the S3 secret access key inline.
                         *     It is provided as a write-only input field for convenience.
                         *     When this field is set, a webhook writes this value in the Secret specified by `credentialsSecretName`
                         *     and empties this field.
                         *     This field is not stored in the API.
                         */
                        secretAccessKey?: string;
                        /**
                         * @description VerifyTLS is set to ensure TLS/SSL verification.
                         *     If unspecified, the default value is true.
                         * @default true
                         */
                        verifyTLS: boolean;
                    };
                };
                /** @description TargetClusterName is the reference to the target cluster. */
                targetClusterName: string;
            };
            status?: {
                /**
                 * Format: date-time
                 * @description CompletedAt is the time when the data import job completed successfully.
                 */
                completedAt?: string;
                /** @description JobName is the reference to the job that is running the data import. */
                jobName?: string;
                /**
                 * Format: int64
                 * @description LastObservedGeneration is the last observed generation of the data import job.
                 */
                lastObservedGeneration?: number;
                /** @description Message is the message of the data import job. */
                message?: string;
                /**
                 * Format: date-time
                 * @description StartedAt is the time when the data import job started.
                 */
                startedAt?: string;
                /** @description State is the current state of the data import job. */
                state?: string;
            };
        };
        /** @description DataImporter defines a reusable strategy for importing data into a DatabaseCluster. */
        DataImporter: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description DataImporterSpec defines the specification of a DataImporter. */
            spec?: {
                /**
                 * @description ClusterPermissions defines the cluster-wide permissions required by the data importer.
                 *     These permissions are used to generate a ClusterRole for the data importer job.
                 */
                clusterPermissions?: {
                    /**
                     * @description APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
                     *     the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
                     */
                    apiGroups?: string[];
                    /**
                     * @description NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
                     *     Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
                     *     Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
                     */
                    nonResourceURLs?: string[];
                    /** @description ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
                    resourceNames?: string[];
                    /** @description Resources is a list of resources this rule applies to. '*' represents all resources. */
                    resources?: string[];
                    /** @description Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs. */
                    verbs: string[];
                }[];
                /** @description Config contains additional configuration defined for the data importer. */
                config?: {
                    /** @description OpenAPIV3Schema is the OpenAPI v3 schema of the data importer. */
                    openAPIV3Schema?: unknown;
                };
                /**
                 * @description DatabaseClusterConstraints defines compatibility requirements and prerequisites that must be satisfied
                 *     by a DatabaseCluster before this data importer can be used with it. This allows the data importer to
                 *     express specific requirements about the database configuration needed for successful import operations,
                 *     such as required database fields, specific engine configurations, or other database properties.
                 *     When a DatabaseCluster references this data importer, the operator will validate the DatabaseCluster
                 *     against these constraints before proceeding with the import operation.
                 */
                databaseClusterConstraints?: {
                    /**
                     * @description RequiredFields contains a list of fields that must be set in the DatabaseCluster spec.
                     *     Each key is a JSON path expressions that points to a field in the DatabaseCluster spec.
                     *     For example, ".spec.engine.type" or ".spec.dataSource.dataImport.config.someField".
                     */
                    requiredFields?: string[];
                };
                /** @description Description is the description of the data importer. */
                description?: string;
                /** @description DisplayName is a human-readable name for the data importer. */
                displayName?: string;
                /** @description JobSpec is the specification of the data importer job. */
                jobSpec?: {
                    /** @description Command is the command to run the data importer. */
                    command?: string[];
                    /** @description Image is the image of the data importer. */
                    image?: string;
                };
                /**
                 * @description Permissions defines the permissions required by the data importer.
                 *     These permissions are used to generate a Role for the data importer job.
                 */
                permissions?: {
                    /**
                     * @description APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
                     *     the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
                     */
                    apiGroups?: string[];
                    /**
                     * @description NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
                     *     Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
                     *     Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
                     */
                    nonResourceURLs?: string[];
                    /** @description ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
                    resourceNames?: string[];
                    /** @description Resources is a list of resources this rule applies to. '*' represents all resources. */
                    resources?: string[];
                    /** @description Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs. */
                    verbs: string[];
                }[];
                /** @description SupportedEngines is the list of engines that the data importer supports. */
                supportedEngines?: string[];
            };
            status?: Record<string, never>;
        };
        /** @description DataImportJobList is an object that contains the list of the existing data import jobs. */
        DataImportJobList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DataImportJob"][];
            metadata?: Record<string, never>;
        };
        /** @description DataImporterList is an object that contains the list of the existing data importers. */
        DataImporterList: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            items?: components["schemas"]["DataImporter"][];
            metadata?: Record<string, never>;
        };
        /** @description PodSchedulingPolicy is the Schema for the Pod Scheduling Policy API. */
        PodSchedulingPolicy: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description PodSchedulingPolicySpec defines the desired state of PodSchedulingPolicy. */
            spec?: {
                /** @description AffinityConfig is a configuration for the affinity settings depending on the engine type. */
                affinityConfig?: {
                    /** @description PostgreSQL is the affinity configuration for the PostgreSQL DB clusters. */
                    postgresql?: {
                        /** @description Engine is the affinity configuration for the DB Engine pods. */
                        engine?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                        /** @description Proxy is the affinity configuration for the DB Proxy pods. */
                        proxy?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                    };
                    /** @description PSMDB is the affinity configuration for the PSMDB DB clusters. */
                    psmdb?: {
                        /** @description ConfigServer is the affinity configuration for the DB Config Server pods. */
                        configServer?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                        /** @description Engine is the affinity configuration for the DB Engine pods. */
                        engine?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                        /** @description Proxy is the affinity configuration for the DB Proxy pods. */
                        proxy?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                    };
                    /** @description PXC is the affinity configuration for the PXC DB clusters. */
                    pxc?: {
                        /** @description Engine is the affinity configuration for the DB Engine pods. */
                        engine?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                        /** @description Proxy is the affinity configuration for the DB Proxy pods. */
                        proxy?: {
                            /** @description Describes node affinity scheduling rules for the pod. */
                            nodeAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node matches the corresponding matchExpressions; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description A node selector term, associated with the corresponding weight. */
                                    preference: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to an update), the system
                                 *     may or may not try to eventually evict the pod from its node.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A list of node selector terms. The terms are ORed. */
                                    nodeSelectorTerms: {
                                        /** @description A list of node selector requirements by node's labels. */
                                        matchExpressions?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /** @description A list of node selector requirements by node's fields. */
                                        matchFields?: {
                                            /** @description The label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description Represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                                             */
                                            operator: string;
                                            /**
                                             * @description An array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. If the operator is Gt or Lt, the values
                                             *     array must have a single element, which will be interpreted as an integer.
                                             *     This array is replaced during a strategic merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                    }[];
                                };
                            };
                            /** @description Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
                            podAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                            /** @description Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
                            podAntiAffinity?: {
                                /**
                                 * @description The scheduler will prefer to schedule pods to nodes that satisfy
                                 *     the anti-affinity expressions specified by this field, but it may choose
                                 *     a node that violates one or more of the expressions. The node that is
                                 *     most preferred is the one with the greatest sum of weights, i.e.
                                 *     for each node that meets all of the scheduling requirements (resource
                                 *     request, requiredDuringScheduling anti-affinity expressions, etc.),
                                 *     compute a sum by iterating through the elements of this field and adding
                                 *     "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
                                 *     node(s) with the highest sum are the most preferred.
                                 */
                                preferredDuringSchedulingIgnoredDuringExecution?: {
                                    /** @description Required. A pod affinity term, associated with the corresponding weight. */
                                    podAffinityTerm: {
                                        /**
                                         * @description A label query over a set of resources, in this case pods.
                                         *     If it's null, this PodAffinityTerm matches with no Pods.
                                         */
                                        labelSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                         *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        matchLabelKeys?: string[];
                                        /**
                                         * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                         *     be taken into consideration. The keys are used to lookup values from the
                                         *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                         *     to select the group of existing pods which pods will be taken into consideration
                                         *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                         *     pod labels will be ignored. The default value is empty.
                                         *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                         *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                         */
                                        mismatchLabelKeys?: string[];
                                        /**
                                         * @description A label query over the set of namespaces that the term applies to.
                                         *     The term is applied to the union of the namespaces selected by this field
                                         *     and the ones listed in the namespaces field.
                                         *     null selector and null or empty namespaces list means "this pod's namespace".
                                         *     An empty selector ({}) matches all namespaces.
                                         */
                                        namespaceSelector?: {
                                            /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                            matchExpressions?: {
                                                /** @description key is the label key that the selector applies to. */
                                                key: string;
                                                /**
                                                 * @description operator represents a key's relationship to a set of values.
                                                 *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                                 */
                                                operator: string;
                                                /**
                                                 * @description values is an array of string values. If the operator is In or NotIn,
                                                 *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                                 *     the values array must be empty. This array is replaced during a strategic
                                                 *     merge patch.
                                                 */
                                                values?: string[];
                                            }[];
                                            /**
                                             * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                             *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                             *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                             */
                                            matchLabels?: {
                                                [key: string]: string;
                                            };
                                        };
                                        /**
                                         * @description namespaces specifies a static list of namespace names that the term applies to.
                                         *     The term is applied to the union of the namespaces listed in this field
                                         *     and the ones selected by namespaceSelector.
                                         *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                         */
                                        namespaces?: string[];
                                        /**
                                         * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                         *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                         *     whose value of the label with key topologyKey matches that of any node on which any of the
                                         *     selected pods is running.
                                         *     Empty topologyKey is not allowed.
                                         */
                                        topologyKey: string;
                                    };
                                    /**
                                     * Format: int32
                                     * @description weight associated with matching the corresponding podAffinityTerm,
                                     *     in the range 1-100.
                                     */
                                    weight: number;
                                }[];
                                /**
                                 * @description If the anti-affinity requirements specified by this field are not met at
                                 *     scheduling time, the pod will not be scheduled onto the node.
                                 *     If the anti-affinity requirements specified by this field cease to be met
                                 *     at some point during pod execution (e.g. due to a pod label update), the
                                 *     system may or may not try to eventually evict the pod from its node.
                                 *     When there are multiple elements, the lists of nodes corresponding to each
                                 *     podAffinityTerm are intersected, i.e. all terms must be satisfied.
                                 */
                                requiredDuringSchedulingIgnoredDuringExecution?: {
                                    /**
                                     * @description A label query over a set of resources, in this case pods.
                                     *     If it's null, this PodAffinityTerm matches with no Pods.
                                     */
                                    labelSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description MatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both matchLabelKeys and labelSelector.
                                     *     Also, matchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    matchLabelKeys?: string[];
                                    /**
                                     * @description MismatchLabelKeys is a set of pod label keys to select which pods will
                                     *     be taken into consideration. The keys are used to lookup values from the
                                     *     incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
                                     *     to select the group of existing pods which pods will be taken into consideration
                                     *     for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
                                     *     pod labels will be ignored. The default value is empty.
                                     *     The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
                                     *     Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
                                     */
                                    mismatchLabelKeys?: string[];
                                    /**
                                     * @description A label query over the set of namespaces that the term applies to.
                                     *     The term is applied to the union of the namespaces selected by this field
                                     *     and the ones listed in the namespaces field.
                                     *     null selector and null or empty namespaces list means "this pod's namespace".
                                     *     An empty selector ({}) matches all namespaces.
                                     */
                                    namespaceSelector?: {
                                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                                        matchExpressions?: {
                                            /** @description key is the label key that the selector applies to. */
                                            key: string;
                                            /**
                                             * @description operator represents a key's relationship to a set of values.
                                             *     Valid operators are In, NotIn, Exists and DoesNotExist.
                                             */
                                            operator: string;
                                            /**
                                             * @description values is an array of string values. If the operator is In or NotIn,
                                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                                             *     the values array must be empty. This array is replaced during a strategic
                                             *     merge patch.
                                             */
                                            values?: string[];
                                        }[];
                                        /**
                                         * @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                                         *     operator is "In", and the values array contains only "value". The requirements are ANDed.
                                         */
                                        matchLabels?: {
                                            [key: string]: string;
                                        };
                                    };
                                    /**
                                     * @description namespaces specifies a static list of namespace names that the term applies to.
                                     *     The term is applied to the union of the namespaces listed in this field
                                     *     and the ones selected by namespaceSelector.
                                     *     null or empty namespaces list and null namespaceSelector means "this pod's namespace".
                                     */
                                    namespaces?: string[];
                                    /**
                                     * @description This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
                                     *     the labelSelector in the specified namespaces, where co-located is defined as running on a node
                                     *     whose value of the label with key topologyKey matches that of any node on which any of the
                                     *     selected pods is running.
                                     *     Empty topologyKey is not allowed.
                                     */
                                    topologyKey: string;
                                }[];
                            };
                        };
                    };
                };
                /**
                 * @description EngineType is type of DB engine that this policy can be applied to.
                 * @enum {string}
                 */
                engineType: "pxc" | "postgresql" | "psmdb";
            };
            /**
             * @description PodSchedulingPolicyStatus defines the observed state of PodSchedulingPolicy.
             * @default {
             *       "inUse": false
             *     }
             */
            status: {
                /**
                 * @description InUse is a flag that indicates if the policy is used by any DB cluster.
                 * @default false
                 */
                inUse: boolean;
                /**
                 * Format: int64
                 * @description LastObservedGeneration is the most recent generation observed for this PodSchedulingPolicy.
                 */
                lastObservedGeneration?: number;
            };
        };
        /** @description LoadBalancerConfig is the Schema for the Load Balancer Config API. */
        LoadBalancerConfig: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description LoadBalancerConfigSpec defines the desired state of LoadBalancerConfig. */
            spec?: {
                /** @description Annotations key-value pairs to apply as annotations to the load balancer */
                annotations?: {
                    [key: string]: string;
                };
            };
            /**
             * @description LoadBalancerConfigStatus defines the observed state of LoadBalancerConfig.
             * @default {
             *       "inUse": false
             *     }
             */
            status: {
                /**
                 * @description InUse is a flag that indicates if the config is used by any DB cluster.
                 * @default false
                 */
                inUse: boolean;
                /**
                 * Format: int64
                 * @description LastObservedGeneration is the most recent generation observed for this LoadBalancerConfig.
                 */
                lastObservedGeneration?: number;
            };
        };
        /**
         * @description StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.
         *
         *     StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
         */
        StorageClass: {
            /** @description allowVolumeExpansion shows whether the storage class allow volume expand. */
            allowVolumeExpansion?: boolean;
            /** @description Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata */
            metadata?: Record<string, never>;
        };
        /** @description Status is a return value for calls that don't return other objects. */
        "io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2": {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /**
             * Format: int32
             * @description Suggested HTTP return code for this status, 0 if not set.
             */
            code?: number;
            /** @description Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type. */
            details?: components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v2"];
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            /** @description A human-readable description of the status of this operation. */
            message?: string;
            /** @description Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            metadata?: components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"];
            /** @description A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it. */
            reason?: string;
            /** @description Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status */
            status?: string;
        };
        /** @description Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes. */
        Secret: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4 */
            data?: {
                [key: string]: string;
            };
            /** @description Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil. */
            immutable?: boolean;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            /** @description Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata */
            metadata?: Record<string, never>;
            /** @description stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API. */
            stringData?: {
                [key: string]: string;
            };
            /** @description Used to facilitate programmatic handling of secret data. More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types */
            type?: string;
        };
        /** @description ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
        "io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta": {
            /** @description continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message. */
            continue?: string;
            /**
             * Format: int64
             * @description remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
             */
            remainingItemCount?: number;
            /** @description String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
            resourceVersion?: string;
            /**
             * @description selfLink is a URL representing this object. Populated by the system. Read-only.
             *
             *     DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.
             */
            selfLink?: string;
        };
        /** @description StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
        "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v2": {
            /** @description The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes. */
            causes?: components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"][];
            /** @description The group attribute of the resource associated with the status StatusReason. */
            group?: string;
            /** @description The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            /** @description The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described). */
            name?: string;
            /**
             * Format: int32
             * @description If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.
             */
            retryAfterSeconds?: number;
            /** @description UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids */
            uid?: string;
        };
        /** @description StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
        "io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause": {
            /**
             * @description The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
             *
             *     Examples:
             *       "name" - the field "name" on the current resource
             *       "items[0].name" - the field "name" on the first array entry in "items"
             */
            field?: string;
            /** @description A human-readable description of the cause of the error.  This field may be presented as-is to a reader. */
            message?: string;
            /** @description A machine-readable description of the cause of the error. If this value is empty there is no information available. */
            reason?: string;
        };
        /** @description SplitHorizonDNSConfig is the Schema for the splithorizondnsconfigs API. */
        SplitHorizonDNSConfig: {
            /**
             * @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: string;
            /**
             * @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            metadata?: Record<string, never>;
            /** @description Spec defines the desired state of SplitHorizonDNSConfig */
            spec: {
                /**
                 * @description BaseDomainNameSuffix is the base domain name suffix for generating domain names for each Pod in ReplicaSet.
                 *     It should be a valid domain name suffix.
                 * @example example.com
                 */
                baseDomainNameSuffix: string;
                /** @description TLS is the TLS configuration for the split-horizon DNS configuration. */
                tls: {
                    /** @description Certificate is the TLS certificate and key for the split-horizon DNS configuration. */
                    certificate?: {
                        /**
                         * @description CACert is based64 encoded ca.pem file content.
                         *     It is provided as a write-only input field for convenience.
                         *     When this field is set, a webhook writes this value in the Secret specified by `.spec.tls.secretName`
                         *     and empties this field.
                         *     This field is not stored in the API.
                         */
                        "ca.crt": string;
                        /**
                         * @description CA Private Key is based64 encoded ca-key.pem file content.
                         *     It is provided as a write-only input field for convenience.
                         *     When this field is set, a webhook writes this value in the Secret specified by `.spec.tls.secretName`
                         *     and empties this field.
                         *     This field is not stored in the API.
                         */
                        "ca.key": string;
                    };
                    /**
                     * @description SecretName is the name of the secret containing the TLS certificate and key for the split-horizon DNS configuration.
                     * @example my-tls-secret
                     */
                    secretName: string;
                };
            };
            /**
             * @description Status defines the observed state of SplitHorizonDNSConfig
             * @default {
             *       "inUse": false
             *     }
             */
            status: {
                /**
                 * @description InUse is a flag that indicates if the config is used by any DB cluster.
                 * @default false
                 */
                inUse: boolean;
                /**
                 * Format: int64
                 * @description LastObservedGeneration is the most recent generation observed for this SplitHorizonDNSConfig.
                 */
                lastObservedGeneration?: number;
            };
        };
        /** @description SplitHorizonDNSConfigUpdateParams is the Schema for the splithorizondnsconfigs update API. */
        SplitHorizonDNSConfigUpdateParams: {
            /**
             * @description BaseDomainNameSuffix is the base domain name suffix for generating domain names for each Pod in ReplicaSet.
             *     It should be a valid domain name suffix.
             * @example example.com
             */
            baseDomainNameSuffix?: string;
            /** @description Certificate is the TLS certificate and key for the split-horizon DNS configuration. */
            certificate?: {
                /**
                 * @description CACert is based64 encoded ca.pem file content.
                 *     It is provided as a write-only input field for convenience.
                 *     When this field is set, a webhook writes this value in the Secret specified by `.spec.tls.secretName`
                 *     and empties this field.
                 *     This field is not stored in the API.
                 */
                "ca.crt": string;
                /**
                 * @description CAKey is based64 encoded ca-key.pem file content.
                 *     It is provided as a write-only input field for convenience.
                 *     When this field is set, a webhook writes this value in the Secret specified by `.spec.tls.secretName`
                 *     and empties this field.
                 *     This field is not stored in the API.
                 */
                "ca.key": string;
            };
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createSession: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The user credentials */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCredentials"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        token?: string;
                    };
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Too many attempts */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteSession: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many attempts */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUserPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserPermissions"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listNamespaces: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespaceList"];
                };
            };
        };
    };
    versionInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Version"];
                };
            };
        };
    };
    getSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Settings"];
                };
            };
        };
    };
    getKubernetesClusterResources: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KubernetesClusterResources"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getKubernetesClusterInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KubernetesClusterInfo"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDatabaseClusters: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createDatabaseCluster: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The database cluster object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseCluster"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseCluster"];
                };
            };
            /** @description Created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseCluster"];
                };
            };
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseCluster"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseCluster: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseCluster"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDatabaseCluster: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The database cluster object to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseCluster"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseCluster"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteDatabaseCluster: {
        parameters: {
            query?: {
                /** @description If set, remove the backed up data from storage */
                cleanupBackupStorage?: boolean;
            };
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDatabaseClusterBackups: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                "cluster-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterBackupList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDatabaseClusterRestores: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                "cluster-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestoreList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseClusterCredentials: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterCredential"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseClusterPitr: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterPitr"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseClusterComponents: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterComponents"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDataImportJobs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster. Can be found under Metadata["name"] of the DatabaseCluster object. */
                dbName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataImportJobList"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createDatabaseClusterSecret: {
        parameters: {
            query?: {
                /** @description Optional name of the secret to be created. If not provided, a random name will be generated. */
                secretName?: string;
            };
            header?: never;
            path: {
                /** @description Name of the database cluster */
                dbName: string;
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The Secret object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Secret"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Secret"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDatabaseEngines: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseEngineList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseEngine: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database engine */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseEngine"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDatabaseEngine: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database engine */
                name: string;
            };
            cookie?: never;
        };
        /** @description The database cluster object to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseEngine"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseEngine"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUpgradePlan: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpgradePlan"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    approveUpgradePlan: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description Request for upgrading the database engine operators */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpgradePlanApproval"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createDatabaseClusterRestore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The database cluster restore object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseClusterRestore"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Created success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseClusterRestore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster restore. Can be found under Metadata["name"] of the DatabaseClusterRestore object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateDatabaseClusterRestore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster restore. Can be found under Metadata["name"] of the DatabaseClusterRestore object. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The database cluster restore object to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseClusterRestore"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Created successful */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterRestore"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteDatabaseClusterRestore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster restore. Can be found under Metadata["name"] of the DatabaseClusterRestore object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createDatabaseClusterBackup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The database cluster backup object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DatabaseClusterBackup"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterBackup"];
                };
            };
            /** @description Created success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterBackup"];
                };
            };
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterBackup"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getDatabaseClusterBackup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster backup. Can be found under Metadata["name"] of the DatabaseClusterBackup object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseClusterBackup"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteDatabaseClusterBackup: {
        parameters: {
            query?: {
                /** @description If set, remove the backed up data from storage */
                cleanupBackupStorage?: boolean;
            };
            header?: never;
            path: {
                /** @description Name of the namespace */
                namespace: string;
                /** @description Name of the database cluster backup. Can be found under Metadata["name"] of the DatabaseClusterBackup object. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listBackupStorages: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BackupStoragesList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createBackupStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The backup storage object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBackupStorageParams"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BackupStorage"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getBackupStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the backup storage */
                name: string;
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BackupStorage"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteBackupStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the backup storage */
                name: string;
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateBackupStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the backup storage */
                name: string;
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The backup storage params. Only the specified fields will be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateBackupStorageParams"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BackupStorage"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listMonitoringInstances: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringInstancesList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createMonitoringInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the backup storage */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The Monitoring instance object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoringInstanceCreateParams"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringInstance"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getMonitoringInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the Monitoring instance */
                name: string;
                /** @description Namespace of the Monitoring instance */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringInstance"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Monitoring instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteMonitoringInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the monitoring instance */
                name: string;
                /** @description Namespace of the Monitoring instance */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Monitoring instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateMonitoringInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the monitoring instance */
                name: string;
                /** @description Namespace of the Monitoring instance */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The monitoring instance object to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoringInstanceUpdateParams"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringInstance"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Monitoring instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listPodSchedulingPolicy: {
        parameters: {
            query?: {
                /** @description Database engine type that Pod Scheduling Policy is applicable to. */
                engineType?: "pxc" | "psmdb" | "postgresql";
                /** @description Return list of Pod Scheduling Policy that has at least 1 rule. */
                hasRules?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PodSchedulingPolicyList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createPodSchedulingPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The pod scheduling policy object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["PodSchedulingPolicy"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PodSchedulingPolicy"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getPodSchedulingPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the pod scheduling policy. Can be found under Metadata["name"] of the PodSchedulingPolicy object. */
                "policy-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PodSchedulingPolicy"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updatePodSchedulingPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the pod scheduling policy. Can be found under Metadata["name"] of the PodSchedulingPolicy object. */
                "policy-name": string;
            };
            cookie?: never;
        };
        /** @description The pod scheduling policy object to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["PodSchedulingPolicy"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PodSchedulingPolicy"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deletePodSchedulingPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the pod scheduling policy. Can be found under Metadata["name"] of the PodSchedulingPolicy object. */
                "policy-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listDataImporters: {
        parameters: {
            query?: {
                /** @description Filter data importers by supported database engine type. Accepts a comma-separated list. */
                supportedEngines?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataImporterList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listLoadBalancerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoadBalancerConfigList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createLoadBalancerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The load balancer config object to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoadBalancerConfig"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoadBalancerConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getLoadBalancerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the load balancer config. Can be found under Metadata["name"] of the LoadBalancerConfig object. */
                "config-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoadBalancerConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateLoadBalancerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the load balancer config. Can be found under Metadata["name"] of the LoadBalancerConfig object. */
                "config-name": string;
            };
            cookie?: never;
        };
        /** @description The load balancer config object to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoadBalancerConfig"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoadBalancerConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteLoadBalancerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the load balancer config. Can be found under Metadata["name"] of the LoadBalancerConfig object. */
                "config-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listSplitHorizonDNSConfigs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the Split-Horizon DNS Config instance. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SplitHorizonDNSConfigList"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createSplitHorizonDNSConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Namespace of the Split-Horizon DNS Config instance. */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The Split-Horizon DNS Config instance object to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SplitHorizonDNSConfig"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SplitHorizonDNSConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getSplitHorizonDNSConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the Split-Horizon DNS Config instance. */
                name: string;
                /** @description Namespace of the Split-Horizon DNS Config instance. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SplitHorizonDNSConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Split-Horizon DNS Config instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteSplitHorizonDNSConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the Split-Horizon DNS Config instance. */
                name: string;
                /** @description Namespace of the Split-Horizon DNS Config instance. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Split-Horizon DNS Config instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateSplitHorizonDNSConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the Split-Horizon DNS Config instance. */
                name: string;
                /** @description Namespace of the SplitHorizonDNSConfig instance. */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The Split-Horizon DNS Config instance object to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SplitHorizonDNSConfigUpdateParams"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SplitHorizonDNSConfig"];
                };
            };
            /** @description Unsuccessful operation */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Split-Horizon DNS Config instance not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
